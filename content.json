{"meta":{"title":"这个爱酱不太聪明","subtitle":"","description":"技术宅改变世界","author":"这个爱酱不太聪明","url":"https://wanwan-doudou/github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"08-31","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"08-31","excerpt":""},{"title":"gallery","text":"","path":"gallery/index.html","date":"04-10","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"08-31","excerpt":""},{"title":"文章分类","text":"","path":"tags/index.html","date":"01-07","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"08-31","excerpt":""}],"posts":[{"title":"使用docker-compose部署项目","text":"1. 使用PowerShell构建项目123$env:GOOS=&quot;linux&quot;$env:GOARCH=&quot;amd64&quot;go build -o main 2. 上传配置文件和构建的二进制文件编写 Dockerfile12345678910111213141516# 使用更小的基础镜像 FROM alpine:latest # 安装运行 Go 程序所需的依赖 RUN apk --no-cache add ca-certificates # 复制二进制文件到镜像中 COPY ./main /usr/local/bin/main RUN chmod +x /usr/local/bin/main # 创建配置目录并复制所有配置文件到镜像中 RUN mkdir /conf COPY ./*.yaml /conf/ # 设置容器启动命令 CMD [&quot;/usr/local/bin/main&quot;, &quot;web&quot;, &quot;-d&quot;, &quot;/conf&quot;] 项目配置文件中的ip可以使用容器 服务的名称例如： 12345678cache: name: redis redis: driver: redis #address: &#x27;127.0.0.1:6379&#x27; address: &#x27;redis:6379&#x27; # 修改为服务名称 password: 123456 db: 0 3. 构建镜像1docker build -t qaps . 4. 创建project文件夹这里存放有关的配置12345678910111213141516171819202122project/├── docker-compose.yml├── Dockerfile├── config/│ ├── redis/│ │ └── redis.conf│ ├── clickhouse/│ │ ├── config.xml│ │ └── users.xml│ ├── mysql/│ │ └── my.cnf│ └── rabbitmq/│ └── rabbitmq.conf├── data/│ ├── redis/│ ├── clickhouse/│ ├── mysql/│ └── rabbitmq/└── logs/ ├── clickhouse/ ├── mysql/ └── rabbitmq/ 5. 编写docker-compose.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980version: &#x27;3.8&#x27; services: go-app: image: qaps:latest container_name: go-app restart: always depends_on: - redis - clickhouse - mysql - rabbitmq ports: - &quot;9010:9010&quot; networks: - app-network redis: image: redis:latest container_name: redis restart: always volumes: - ./data/redis:/data - ./config/redis/redis.conf:/usr/local/etc/redis/redis.conf command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;] ports: - &quot;6379:6379&quot; networks: - app-network clickhouse: image: clickhouse/clickhouse-server:latest container_name: clickhouse restart: always cap_add: - SYS_NICE volumes: - ./data/clickhouse:/var/lib/clickhouse - ./config/clickhouse/config.xml:/etc/clickhouse-server/config.xml - ./config/clickhouse/users.xml:/etc/clickhouse-server/users.xml - ./logs/clickhouse:/var/log/clickhouse-server ports: - &quot;8123:8123&quot; - &quot;9000:9000&quot; - &quot;9009:9009&quot; networks: - app-network mysql: image: mysql:latest container_name: mysql restart: always environment: MYSQL_ROOT_PASSWORD: &quot;123456&quot; volumes: - ./data/mysql:/var/lib/mysql - ./config/mysql/my.cnf:/etc/mysql/my.cnf - ./logs/mysql:/var/log/mysql ports: - &quot;3306:3306&quot; networks: - app-network rabbitmq: image: rabbitmq:management container_name: rabbitmq restart: always volumes: - ./data/rabbitmq:/var/lib/rabbitmq/mnesia - ./logs/rabbitmq:/var/log/rabbitmq - ./config/rabbitmq/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf ports: - &quot;5672:5672&quot; - &quot;15672:15672&quot; networks: - app-network networks: app-network: driver: bridge 启动1docker-compose up -d 以下是一些常用的 docker-compose 命令： 123456789101112131415161718192021222324252627282930313233343536**后台启动服务（以分离模式运行）**：docker-compose up -d**前台启动服务（日志会显示在终端）**：docker-compose up**停止正在运行的服务，但不删除容器**：docker-compose stop**停止并删除容器、网络和在 `docker-compose.yml` 中定义的卷**：docker-compose down**构建或重新构建服务（如果修改了 Dockerfile，可以使用此命令）**：docker-compose build**查看所有服务的日志**：docker-compose logs**实时显示日志（跟踪日志）**：docker-compose logs -f**列出 Docker Compose 管理的所有容器**：docker-compose ps**在运行中的容器内执行命令（例如启动一个 bash shell）**：docker-compose exec &lt;服务名&gt; bash**运行一次性命令（在新容器中运行单个命令）**：docker-compose run &lt;服务名&gt; &lt;命令&gt;**查看当前配置的服务**：docker-compose config**删除所有停止的容器、未使用的网络以及悬挂的镜像**：docker-compose down --volumes --remove-orphans","path":"2024/11/22/使用docker-compose部署项目/","date":"11-22","excerpt":"","tags":[{"name":"docker","slug":"docker","permalink":"https://wanwan-doudou/github.io/tags/docker/"}]},{"title":"使用docker安装常用环境","text":"安装redis1. 拉取 Redis 镜像1docker pull redis:latest 2. 创建挂载目录Redis 的数据需要持久化到本地文件系统，因此需要创建挂载目录： 12mkdir -p /mydata/redis/datamkdir -p /mydata/redis/conf 3.准备配置文件以下是一个完整的 Redis 配置文件 redis.conf 示例，针对你要求的持久化、密码配置和常用设置已经做好调整。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Redis 通用配置# 监听地址，允许所有 IP 访问（不建议在生产环境中使用）bind 0.0.0.0# 端口号port 6379# 设置 Redis 密码requirepass 123456# 关闭保护模式（允许外部访问）protected-mode no# 持久化配置# 快照持久化（RDB 配置）# 按时间间隔和操作次数保存数据，示例为：# - 每 900 秒（15 分钟）至少有 1 次修改# - 每 300 秒（5 分钟）至少有 10 次修改# - 每 60 秒（1 分钟）至少有 10000 次修改save 900 1save 300 10save 60 10000# 持久化文件名dbfilename dump.rdb# 持久化文件保存目录dir /data# AOF 持久化（日志追加模式）# 启用 AOF（默认关闭）appendonly yes# AOF 文件名appendfilename &quot;appendonly.aof&quot;# AOF 的文件同步策略# - always: 每次写入都同步（性能差，最安全）# - everysec: 每秒同步一次（推荐，权衡性能和安全性）# - no: 由操作系统决定同步时间（性能最好，安全性低）appendfsync everysec# 性能优化# 指定最大客户端连接数，0 表示无限制maxclients 10000# 限制内存大小，单位字节（示例为 1GB，生产环境建议配置）# maxmemory 1073741824# 内存超出限制时的淘汰策略# 可选值：# - noeviction: 不再接受写入操作（默认）# - allkeys-lru: 淘汰最少使用的键# - volatile-lru: 在设置过期时间的键中淘汰最少使用的键# - allkeys-random: 随机淘汰键# - volatile-random: 在设置过期时间的键中随机淘汰# - volatile-ttl: 在设置过期时间的键中淘汰存活时间最短的键# maxmemory-policy allkeys-lru# 日志配置# 日志级别（可选：debug、verbose、notice、warning）loglevel notice# 日志文件路径（默认输出到标准输出）# logfile &quot;/data/redis.log&quot;# 后台运行# 注意：在 Docker 中，不需要开启此选项，保持为 no 即可daemonize no 使用说明 文件保存位置 将以上内容保存到 /mydata/redis/conf/redis.conf 文件中。 启动 Redis 容器 使用以下命令运行容器，并挂载配置文件和数据目录 12345678docker run -d \\ --name redis \\ --restart=always \\ -p 6379:6379 \\ -v /mydata/redis/data:/data \\ -v /mydata/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf \\ redis:latest \\ redis-server /usr/local/etc/redis/redis.conf 安装 clickhouse1. 拉取 ClickHouse 镜像首先从 Docker Hub 拉取最新的 ClickHouse 镜像： 1docker pull clickhouse/clickhouse-server:latest 2. 创建挂载目录创建本地目录，用于挂载 ClickHouse 的数据和配置文件： 1234mkdir -p /mydata/clickhouse/datamkdir -p /mydata/clickhouse/configmkdir -p /mydata/clickhouse/log 3. 准备配置文件生成默认配置文件（可选）： 12docker run --rm clickhouse/clickhouse-server cat /etc/clickhouse-server/config.xml &gt; /mydata/clickhouse/config/config.xmldocker run --rm clickhouse/clickhouse-server cat /etc/clickhouse-server/users.xml &gt; /mydata/clickhouse/config/users.xml 配置说明： config.xml 是主配置文件，用于配置存储路径、监听端口等。 users.xml 是用户配置文件，用于设置用户权限、默认密码等。&#96;&#96;1234# config.xml 开启远程登录&lt;listen_host&gt;0.0.0.0&lt;/listen_host&gt; # users.xml 配置密码&lt;password&gt;123456&lt;/password&gt; 4. 启动clickhouse容器1234567891011121314# 添加 CAP_SYS_NICE 容器权限，不然可能会出现这个错误get_mempolicy: Operation not permitteddocker run -d \\ --name clickhouse \\ --restart=always \\ --cap-add=SYS_NICE \\ -p 8123:8123 \\ -p 9000:9000 \\ -p 9009:9009 \\ -v /mydata/clickhouse/data:/var/lib/clickhouse \\ -v /mydata/clickhouse/config/config.xml:/etc/clickhouse-server/config.xml \\ -v /mydata/clickhouse/config/users.xml:/etc/clickhouse-server/users.xml \\ -v /mydata/clickhouse/log:/var/log/clickhouse-server \\ clickhouse/clickhouse-server:latest 安装 MySql1. MySql 镜像首先从 Docker Hub 拉取最新的 MySql 镜像： 1docker pull mysql 2. 创建目录结构在 /mydata 下为 MySQL 创建独立的目录： 123sudo mkdir -p /mydata/mysql/datasudo mkdir -p /mydata/mysql/configsudo mkdir -p /mydata/mysql/logs 3. 挂载目录授权1sudo chown -R 999:999 /mydata/mysql/data 3. 准备 MySQL 配置文件（可选）MySQL 容器允许自定义配置文件。如果需要，可以创建一个配置文件，例如 /mydata/mysql/config/my.cnf，内容如下： 1234567[mysqld]bind-address = 0.0.0.0port = 3306datadir = /var/lib/mysqllog-error = /var/log/mysql/error.logmax_connections = 200sql_mode = &quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot; 4. 启动 MySQL 容器运行以下命令启动 MySQL 容器： 123456789docker run -d \\ --name mysql \\ --restart=always \\ -p 3306:3306 \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -v /mydata/mysql/data:/var/lib/mysql \\ -v /mydata/mysql/config/my.cnf:/etc/mysql/my.cnf \\ -v /mydata/mysql/logs:/var/log/mysql \\ mysql:latest 5. 配置远程访问1. 进入容器并连接到MySQL： 1docker exec -it mysql mysql -u root -p 在 MySQL 命令行中执行以下操作： 2. 检查权限用户验证root用户的主机限制： 1SELECT host, user FROM mysql.user WHERE user = &#x27;root&#x27;; 3. 设置远程权限添加root用户的远程访问权限： 123CREATE USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;your_root_password&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; WITH GRANT OPTION;FLUSH PRIVILEGES; 4. 测试远程用户确保创建远程用户可以访问： 1SELECT host, user FROM mysql.user; 安装 rabbitmq1. 创建所需目录在宿主机上创建用于存储 RabbitMQ 配置和数据的目录： 1mkdir -p /mydata/rabbitmq/data /mydata/rabbitmq/log /mydata/rabbitmq/config 2. 创建配置文件RabbitMQ 可以通过 rabbitmq.conf 或 advanced.config 文件进行配置。这里使用 rabbitmq.conf 文件。 创建 /mydata/rabbitmq/config/rabbitmq.conf 文件并添加以下内容： 123456789# RabbitMQ Configuration File# 默认用户配置default_user = admindefault_pass = 123456# 持久化路径（数据和日志）log.dir = /var/log/rabbitmqraft.data_dir = /var/lib/rabbitmq/mnesia 3. 启动 RabbitMQ 容器运行以下命令启动 RabbitMQ 容器，并将配置和数据挂载到宿主机： 12345678910docker run -d \\ --name rabbitmq \\ --restart=always \\ -p 5672:5672 \\ -p 15672:15672 \\ -v /mydata/rabbitmq/data:/var/lib/rabbitmq/mnesia \\ -v /mydata/rabbitmq/log:/var/log/rabbitmq \\ -v /mydata/rabbitmq/config/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \\ rabbitmq:management 4、进入容器内部12docker exec -it 容器id /bin/bsshrabbitmq-plugins enable rabbitmq_management","path":"2024/11/21/使用docker安装常用环境/","date":"11-21","excerpt":"","tags":[{"name":"docker","slug":"docker","permalink":"https://wanwan-doudou/github.io/tags/docker/"}]},{"title":"使用 Element Plus 实现添加行时单元格合并","text":"在项目中，需要展示设备绑定信息表格。为了简洁地展示数据，主表字段（例如设备唯一标识、设备负责人等）应合并显示相同的内容，而从表字段（例如探针设备、IP 地址等）保持独立显示，避免重复。同时，当点击“添加行”按钮时，新增的行需自动继承主表字段，并完成单元格合并。 实现步骤1. 设置表格和列模板使用 Element Plus 的 &lt;el-table&gt; 和 &lt;el-table-column&gt; 渲染表格，其中 :span-method 属性用于设置单元格合并逻辑。代码如下： 1234567891011121314151617&lt;el-table border :data=&quot;tableData&quot; row-key=&quot;id&quot; :span-method=&quot;spanMethod&quot;&gt; &lt;template v-for=&quot;(propsItem, index) in columnOptions&quot; :key=&quot;index&quot;&gt; &lt;el-table-column :prop=&quot;propsItem.value&quot; :label=&quot;propsItem.label&quot;&gt; &lt;template #default=&quot;&#123; row &#125;&quot;&gt; &lt;el-input v-model=&quot;row[propsItem.value]&quot; placeholder=&quot;输入内容&quot;&gt;&lt;/el-input&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/template&gt; &lt;el-table-column prop=&quot;total2&quot; label=&quot;操作&quot; width=&quot;200&quot; fixed=&quot;right&quot;&gt; &lt;template #default=&quot;scope&quot;&gt; &lt;el-button size=&quot;small&quot; color=&quot;#1F63FF&quot; @click=&quot;addRowBelow(scope.$index)&quot;&gt;添加行&lt;/el-button&gt; &lt;el-button size=&quot;small&quot; color=&quot;#1F63FF&quot; plain @click=&quot;editHandle(scope.row)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button size=&quot;small&quot; type=&quot;danger&quot; plain @click=&quot;deleteHandle(scope.row)&quot;&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt;&lt;/el-table&gt; 2. 定义需要合并的字段定义 columnOptions 列表，列出表格中的各字段，并选择需要合并的主表字段： 12345678910111213const columnOptions = ref([ &#123; label: &quot;设备唯一标识&quot;, value: &quot;unitDeviceCode&quot; &#125;, &#123; label: &quot;设备负责人&quot;, value: &quot;unitDeviceAdmin&quot; &#125;, &#123; label: &quot;电话&quot;, value: &quot;unitDeviceAdminPhone&quot; &#125;, &#123; label: &quot;邮箱&quot;, value: &quot;unitDeviceAdminEmail&quot; &#125;, &#123; label: &quot;硬件类型&quot;, value: &quot;unitDeviceHardwareType&quot; &#125;, &#123; label: &quot;操作系统&quot;, value: &quot;unitDeviceOperatingSystem&quot; &#125;, &#123; label: &quot;探针设备&quot;, value: &quot;routeScannerName&quot; &#125;, &#123; label: &quot;IP地址&quot;, value: &quot;unitDeviceIp&quot; &#125;, &#123; label: &quot;设备网关IP地址&quot;, value: &quot;macIp&quot; &#125;, &#123; label: &quot;子网掩码长度&quot;, value: &quot;subnetMaskLength&quot; &#125;]); 3. 实现 spanMethod 函数进行单元格合并spanMethod 函数根据字段内容合并单元格。主表字段内容相同时，进行合并显示；否则显示独立单元格。代码如下： 123456789101112131415const spanMethod = (&#123; row, column, rowIndex, columnIndex &#125;) =&gt; &#123; const mergeColumns = [&quot;unitDeviceCode&quot;, &quot;unitDeviceAdmin&quot;, &quot;unitDeviceAdminPhone&quot;, &quot;unitDeviceAdminEmail&quot;, &quot;unitDeviceHardwareType&quot;, &quot;unitDeviceOperatingSystem&quot;]; if (mergeColumns.includes(column.property)) &#123; if (rowIndex &gt; 0 &amp;&amp; row[column.property] === tableData.value[rowIndex - 1][column.property]) &#123; return [0, 0]; // 当前单元格不显示 &#125; let rowspan = 1; while (rowIndex + rowspan &lt; tableData.value.length &amp;&amp; tableData.value[rowIndex + rowspan][column.property] === row[column.property]) &#123; rowspan++; &#125; return [rowspan, 1]; &#125; return [1, 1]; // 其他字段不合并&#125;; 4. 添加新行并继承主表字段addRowBelow 函数用于在指定位置添加新行，并继承主表字段内容，确保合并效果。代码如下： 12345678910111213141516const addRowBelow = (index) =&gt; &#123; const newRow = &#123; unitDeviceCode: tableData.value[index].unitDeviceCode, unitDeviceAdmin: tableData.value[index].unitDeviceAdmin, unitDeviceAdminPhone: tableData.value[index].unitDeviceAdminPhone, unitDeviceAdminEmail: tableData.value[index].unitDeviceAdminEmail, unitDeviceHardwareType: tableData.value[index].unitDeviceHardwareType, unitDeviceOperatingSystem: tableData.value[index].unitDeviceOperatingSystem, routeScannerName: &quot;&quot;, // 从表字段留空 unitDeviceIp: &quot;&quot;, macIp: &quot;&quot;, subnetMaskLength: 0 &#125;; tableData.value.splice(index + 1, 0, newRow);&#125;; 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355&lt;template&gt; &lt;div class=&quot;card content-box&quot;&gt; &lt;div class=&quot;page-tag-title&quot;&gt;设备绑定&lt;/div&gt; &lt;div class=&quot;table-box&quot;&gt; &lt;el-form :inline=&quot;true&quot; :model=&quot;formInline&quot;&gt; &lt;el-form-item label=&quot;&quot;&gt; &lt;el-select v-model=&quot;formInline.name&quot; placeholder=&quot;请选择搜索类型&quot; style=&quot;width: 240px&quot;&gt; &lt;el-option v-for=&quot;(item, index) in columnOptions&quot; :key=&quot;index&quot; :label=&quot;item.label&quot; :value=&quot;item.value&quot; /&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;&quot;&gt; &lt;el-input v-model=&quot;formInline.netSegment&quot; placeholder=&quot;请输入搜索关键字&quot; style=&quot;width: 260px&quot; clearable /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button color=&quot;#1F63FF&quot; :icon=&quot;Search&quot; @click=&quot;onSearch&quot;&gt;查询&lt;/el-button&gt; &lt;el-button color=&quot;#1F63FF&quot; :icon=&quot;Plus&quot; @click=&quot;onBinding&quot;&gt;绑定&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-table border :data=&quot;tableData&quot; row-key=&quot;id&quot; :span-method=&quot;spanMethod&quot;&gt; &lt;template v-for=&quot;(propsItem, index) in columnOptions&quot; :key=&quot;index&quot;&gt; &lt;el-table-column :prop=&quot;propsItem.value&quot; :label=&quot;propsItem.label&quot;&gt; &lt;template #default=&quot;&#123; row &#125;&quot;&gt; &lt;el-input v-model=&quot;row[propsItem.value]&quot; placeholder=&quot;输入内容&quot;&gt;&lt;/el-input&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/template&gt; &lt;el-table-column prop=&quot;total2&quot; label=&quot;操作&quot; width=&quot;200&quot; fixed=&quot;right&quot;&gt; &lt;template #default=&quot;scope&quot;&gt; &lt;el-button size=&quot;small&quot; color=&quot;#1F63FF&quot; @click=&quot;addRowBelow(scope.$index)&quot;&gt;添加行&lt;/el-button&gt; &lt;el-button size=&quot;small&quot; color=&quot;#1F63FF&quot; plain @click=&quot;editHandle(scope.row)&quot;&gt;编辑&lt;/el-button&gt; &lt;el-button size=&quot;small&quot; type=&quot;danger&quot; plain @click=&quot;deleteHandle(scope.row)&quot;&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination v-model:current-page=&quot;page.pageNum&quot; v-model:page-size=&quot;page.pageSize&quot; :page-sizes=&quot;[10, 25, 50, 100]&quot; :background=&quot;true&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot; :total=&quot;page.total&quot; @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; /&gt; &lt;/div&gt; &lt;BindingDialog ref=&quot;bindingDialogRef&quot; /&gt; &lt;/div&gt;&lt;/template&gt; &lt;script setup lang=&quot;tsx&quot;&gt;import &#123; ref, reactive &#125; from &quot;vue&quot;;import &#123; Delete, Plus, Search &#125; from &quot;@element-plus/icons-vue&quot;;import BindingDialog from &quot;./components/bindingDialog.vue&quot;; const bindingDialogRef = ref();const formInline = reactive(&#123; name: &quot;&quot;, netSegment: &quot;&quot;&#125;);const columnOptions = ref([ &#123; label: &quot;设备唯一标识&quot;, value: &quot;unitDeviceCode&quot; &#125;, &#123; label: &quot;设备负责人&quot;, value: &quot;unitDeviceAdmin&quot; &#125;, &#123; label: &quot;电话&quot;, value: &quot;unitDeviceAdminPhone&quot; &#125;, &#123; label: &quot;邮箱&quot;, value: &quot;unitDeviceAdminEmail&quot; &#125;, &#123; label: &quot;硬件类型&quot;, value: &quot;unitDeviceHardwareType&quot; &#125;, &#123; label: &quot;操作系统&quot;, value: &quot;unitDeviceOperatingSystem&quot; &#125;, &#123; label: &quot;探针设备&quot;, value: &quot;routeScannerName&quot; &#125;, &#123; label: &quot;IP地址&quot;, value: &quot;unitDeviceIp&quot; &#125;, &#123; label: &quot;设备网关IP地址&quot;, value: &quot;macIp&quot; &#125;, &#123; label: &quot;子网掩码长度&quot;, value: &quot;subnetMaskLength&quot; &#125;,]); const page = reactive(&#123; pageNum: 1, pageSize: 10, total: 0&#125;); const tableData = ref([ &#123; unitDeviceCode: &quot;123456&quot;, unitDeviceAdmin: &quot;张三&quot;, unitDeviceAdminPhone: &quot;13800000000&quot;, unitDeviceAdminEmail: &quot;zhangsan@example.com&quot;, unitDeviceHardwareType: &quot;服务器&quot;, unitDeviceOperatingSystem: &quot;Linux&quot;, routeScannerName: &quot;探针设备1&quot;, unitDeviceIp: &quot;192.168.1.1&quot;, macIp: &quot;192.168.1.254&quot;, subnetMaskLength: 24 &#125;, // 添加初始数据项，您可以增加其他行 &#123; unitDeviceCode: &quot;123456789&quot;, unitDeviceAdmin: &quot;李四&quot;, unitDeviceAdminPhone: &quot;1380000000&quot;, unitDeviceAdminEmail: &quot;zhangsan@exmple.com&quot;, unitDeviceHardwareType: &quot;服务器1&quot;, unitDeviceOperatingSystem: &quot;L1inux&quot;, routeScannerName: &quot;探针设备1&quot;, unitDeviceIp: &quot;192.168.1.1&quot;, macIp: &quot;192.168.1.254&quot;, subnetMaskLength: 24 &#125;]); // 添加空行到指定索引的下方，并填充左侧字段const addRowBelow = (index) =&gt; &#123; const newRow = &#123; unitDeviceCode: tableData.value[index].unitDeviceCode, // 填充上一行的设备唯一标识 unitDeviceAdmin: tableData.value[index].unitDeviceAdmin, // 填充上一行的设备负责人 unitDeviceAdminPhone: tableData.value[index].unitDeviceAdminPhone, unitDeviceAdminEmail: tableData.value[index].unitDeviceAdminEmail, unitDeviceHardwareType: tableData.value[index].unitDeviceHardwareType, unitDeviceOperatingSystem: tableData.value[index].unitDeviceOperatingSystem, routeScannerName: &quot;&quot;, // 其他从表字段留空 unitDeviceIp: &quot;&quot;, macIp: &quot;&quot;, subnetMaskLength: 0 &#125;; tableData.value.splice(index + 1, 0, newRow);&#125;; // 表格单元格合并逻辑const spanMethod = (&#123; row, column, rowIndex, columnIndex &#125;) =&gt; &#123; // 判断合并左侧字段 const mergeColumns = [&quot;unitDeviceCode&quot;, &quot;unitDeviceAdmin&quot;, &quot;unitDeviceAdminPhone&quot;, &quot;unitDeviceAdminEmail&quot;, &quot;unitDeviceHardwareType&quot;, &quot;unitDeviceOperatingSystem&quot;]; if (mergeColumns.includes(column.property)) &#123; // 如果当前行和上一行的值相同，合并 if (rowIndex &gt; 0 &amp;&amp; row[column.property] === tableData.value[rowIndex - 1][column.property]) &#123; return [0, 0]; // 不显示当前单元格 &#125; // 统计连续相同的行数 let rowspan = 1; while (rowIndex + rowspan &lt; tableData.value.length &amp;&amp; tableData.value[rowIndex + rowspan][column.property] === row[column.property]) &#123; rowspan++; &#125; return [rowspan, 1]; &#125; return [1, 1]; // 默认不合并其他字段&#125;; const onSearch = () =&gt; &#123; console.log(&quot;搜索!&quot;);&#125;; const onBinding = () =&gt; &#123; bindingDialogRef.value.openDialog(); console.log(&quot;绑定===&quot;);&#125;; const editHandle = rowData =&gt; &#123; console.log(&quot;编辑===&quot;, rowData);&#125;; const deleteHandle = rowData =&gt; &#123; console.log(&quot;删除===&quot;, rowData);&#125;; const handleSizeChange = val =&gt; &#123; page.pageSize = val;&#125;; const handleCurrentChange = val =&gt; &#123; page.pageNum = val;&#125;;&lt;/script&gt; &lt;style scoped lang=&quot;scss&quot;&gt;.page-tag-title &#123; width: 100%; padding-bottom: 20px; font-size: 18px; color: #292929;&#125; .demo-form-inline .el-input &#123; --el-input-width: 220px;&#125; .demo-form-inline .el-select &#123; --el-select-width: 220px;&#125;&lt;/style&gt; 实现效果如下","path":"2024/11/05/使用-Element-Plus-实现添加行时单元格合并/","date":"11-05","excerpt":"","tags":[{"name":"Vue","slug":"Vue","permalink":"https://wanwan-doudou/github.io/tags/Vue/"}]},{"title":"使用docker安装PaddleOCR","text":"1. 安装必要的系统工具12sudo yum install -y yum-utils device-mapper-persitent-data lvm2sudo yum install -y epel-release 2. 添加阿里云镜像仓库1sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 3.更新并安装Docker-CE12sudo yum makecache fast sudo yum -y install docker-ce 4. 开启Docker服务1sudo service docker start 5. 安装DockerCompose1sudo curl -L &quot;https://github.com/docker/compose/releases/latest/download/docker-compose-Linux-x86_64&quot; -o /usr/local/bin/docker-compose 6. 授予执行权限1sudo chmod +x /usr/local/bin/docker-compose 7. 创建ocr-cpu目录123cd /homemkdir ocr-cpucd ocr-cpu 8. 编写Dockerfile123456789101112131415161718192021222324252627282930313233343536373839404142434445# 使用最新版 Python FROM python:slim # 更新 apt-get 并安装必要的依赖 RUN apt-get update &amp;&amp; \\ apt-get install -y git libgomp1 libgl1-mesa-glx libglib2.0-0 &amp;&amp; \\ rm -rf /var/lib/apt/lists/* # 更新 pip 并安装 setuptools RUN pip install --upgrade pip setuptools -i https://mirrors.aliyun.com/pypi/simple # 安装 paddlepaddle 和 paddlehub（使用最新版） RUN pip install paddlepaddle paddlehub -i https://mirrors.aliyun.com/pypi/simple # **关键修改**：降级 protobuf 到兼容版本 3.20.x，以避免 TypeError 错误 RUN pip install protobuf==3.20.* -i https://mirrors.aliyun.com/pypi/simple # 克隆 PaddleOCR 仓库 RUN git clone https://gitee.com/paddlepaddle/PaddleOCR.git /PaddleOCR WORKDIR /PaddleOCR # 直接安装依赖 RUN pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple # **关键修改**：设置环境变量以避免 protobuf 错误 ENV PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python # 下载并解压模型 ADD https://paddleocr.bj.bcebos.com/PP-OCRv3/chinese/ch_PP-OCRv3_det_infer.tar /PaddleOCR/inference/ RUN tar xf /PaddleOCR/inference/ch_PP-OCRv3_det_infer.tar -C /PaddleOCR/inference/ ADD https://paddleocr.bj.bcebos.com/PP-OCRv3/chinese/ch_PP-OCRv3_rec_infer.tar /PaddleOCR/inference/ RUN tar xf /PaddleOCR/inference/ch_PP-OCRv3_rec_infer.tar -C /PaddleOCR/inference/ ADD https://paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_cls_infer.tar /PaddleOCR/inference/ RUN tar xf /PaddleOCR/inference/ch_ppocr_mobile_v2.0_cls_infer.tar -C /PaddleOCR/inference/ # 安装 OCR 模块 RUN hub install deploy/hubserving/ocr_system/ # 暴露端口 EXPOSE 8866 # 启动 PaddleHub 服务 CMD [&quot;hub&quot;, &quot;serving&quot;, &quot;start&quot;, &quot;-m&quot;, &quot;ocr_system&quot;] 9. 创建 docker-compose.yml 文件12345678910version: &#x27;3&#x27; # 正确的版本声明 services: ocr-cpu: image: ocr-cpu # 注意这里的冒号应为连字符 restart: always hostname: ocr-cpu container_name: ocr-cpu ports: - &quot;8866:8866&quot; # 使用引号包裹端口映射 10. 运行Docker构建命令，docker-compose命令部署12docker build --network=host -t ocr-cpu .docker-compose up -d 11. 查看的容器 12. 编写后端测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package main import ( &quot;bytes&quot; &quot;encoding/base64&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;os&quot;) func main() &#123; // URL 和图片路径设置 url := &quot;http://192.168.31.203:8866/predict/ocr_system&quot; imagePath := `C:\\Users\\doudou\\Desktop\\微信截图_20240929171217.png` // 读取图片 imgFile, err := os.Open(imagePath) if err != nil &#123; fmt.Println(&quot;Error opening image file:&quot;, err) return &#125; defer imgFile.Close() imgData, err := ioutil.ReadAll(imgFile) if err != nil &#123; fmt.Println(&quot;Error reading image file:&quot;, err) return &#125; // Base64 编码 imgBase64 := base64.StdEncoding.EncodeToString(imgData) data := map[string]interface&#123;&#125;&#123; &quot;images&quot;: []string&#123;imgBase64&#125;, &#125; jsonData, err := json.Marshal(data) if err != nil &#123; fmt.Println(&quot;Error marshaling JSON:&quot;, err) return &#125; // 发送请求 req, err := http.NewRequest(&quot;POST&quot;, url, bytes.NewBuffer(jsonData)) if err != nil &#123; fmt.Println(&quot;Error creating request:&quot;, err) return &#125; req.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;) client := &amp;http.Client&#123;&#125; response, err := client.Do(req) if err != nil &#123; fmt.Println(&quot;Error sending request:&quot;, err) return &#125; defer response.Body.Close() body, err := ioutil.ReadAll(response.Body) if err != nil &#123; fmt.Println(&quot;Error reading response body:&quot;, err) return &#125; // 解析 JSON 响应 var result map[string]interface&#123;&#125; if err := json.Unmarshal(body, &amp;result); err != nil &#123; fmt.Println(&quot;Error unmarshaling JSON:&quot;, err) return &#125; // 检查状态 if result[&quot;status&quot;] == &quot;000&quot; &#123; if results, ok := result[&quot;results&quot;].([]interface&#123;&#125;); ok &#123; for _, res := range results &#123; if resList, ok := res.([]interface&#123;&#125;); ok &#123; for _, item := range resList &#123; if itemMap, ok := item.(map[string]interface&#123;&#125;); ok &#123; text := itemMap[&quot;text&quot;].(string) confidence := itemMap[&quot;confidence&quot;].(float64) fmt.Printf(&quot;Text: %s, Confidence: %.2f\\n&quot;, text, confidence) &#125; &#125; &#125; &#125; &#125; &#125; else &#123; fmt.Println(&quot;Error in response:&quot;, result[&quot;msg&quot;]) &#125; &#125; 12. 测试结果","path":"2024/09/29/使用docker安装CPU版本的PaddleOCR/","date":"09-29","excerpt":"","tags":[{"name":"PaddleOCR","slug":"PaddleOCR","permalink":"https://wanwan-doudou/github.io/tags/PaddleOCR/"}]},{"title":"go使用原生mysql跨库操作保证事务一致性","text":"对事物进行了简单的封装12345678910111213141516171819202122232425262728293031323334353637383940414243var ( db *sql.DB ) // BeginTransaction 封装事务 func BeginTransaction(fn func(tx *sql.Tx) error) error &#123; tx, err := db.Begin() if err != nil &#123; return err &#125; err = fn(tx) if err != nil &#123; tx.Rollback() &#125; else &#123; tx.Commit() &#125; return err &#125;func main() &#123; // 设置 MySQL 数据库的连接信息 dsn := &quot;root:123456@tcp(192.168.31.202:3306)/&quot; var err error db, err = sql.Open(&quot;mysql&quot;, dsn) if err != nil &#123; log.Fatal(err) &#125; defer db.Close() BeginTransaction(func(tx *sql.Tx) error &#123; _, err := tx.Exec(`INSERT INTO test.user (id,user) VALUES (6,&quot;小李2&quot;)`) if err != nil &#123; return err &#125; _, err = tx.Exec(`INSERT INTO test1.password (id,user_id,password) VALUES (5,5,&quot;123456&quot;)`) if err != nil &#123; return err &#125; return nil &#125;)&#125;","path":"2024/09/25/go使用原生mysql跨库操作时保证事务一致性/","date":"09-25","excerpt":"","tags":[{"name":"go","slug":"go","permalink":"https://wanwan-doudou/github.io/tags/go/"}]},{"title":"RabbitMQ Web 界面配置解析","text":"Channels（通道）1. Channel（通道名称） 定义：用于标识特定的通道。 用途：方便区分不同的通道，在代码中通过特定的通道名称进行操作。 2. User name（该通道登录使用的用户名） 定义：显示建立该通道所使用的用户名。 用途：有助于识别通道的创建者，进行访问控制和审计。 3. Model（通道确认模式） “C” ：表示 confirm（确认模式）。 “T” ：表示事务transactional。 用途：确定消息在发送和接收过程中的可靠性保障方式。Confirm 模式下，生产者可以通过确认机制确保消息成功发送到 RabbitMQ 服务器；事务模式提供了更严格的事务处理，但性能开销相对较大。 4. State（通道当前的状态） “running”： 表示运行中 “idle”： 表示空闲。 用途：让用户了解通道的当前工作状态。运行中的通道正在处理消息传递或其他操作，空闲状态可能表示当前没有活动的消息传递任务。 5. Unconfirmed（待确认的消息总数） 定义：显示已经发送但尚未被确认的消息数量。 用途：帮助监控消息的传递状态，确保消息被正确处理和确认。如果这个数字过高，可能表示存在消息处理延迟或问题。 6. Prefetch（每个消费者最大的能承受的未确认消息数目） 定义：指定一个消费者一次可以从 RabbitMQ 中获取多少条消息并缓存在消费者中。一旦消费者的缓冲区满了，RabbitMQ 将会停止投递新的消息到该消费者中，直到它发出有消息被 ack（确认）了。 用途：用于调整消费者的消息处理能力，平衡消息的投递速度和消费者的处理速度，避免消息堆积或消费者过载。 7. Unacker（待 ack 的消息总数） 定义：显示消费者尚未确认的消息数量。 用途：与 Unconfirmed 和 Prefetch 一起，用于监控消费者对消息的处理进度和状态。 8. publish（消息生产者发送消息的速率） 定义：表示生产者发送消息的速度，通常以消息数量 &#x2F; 时间单位来衡量。 用途：帮助评估生产者的负载和消息产生的速度，以便调整系统资源或进行性能优化。 9. confirm（消息生产者确认消息的速率） 定义：生产者确认消息的速度，同样以消息数量 &#x2F; 时间单位来衡量。 用途：反映生产者对消息确认的及时性，高确认速率可能表示系统运行良好，低确认速率可能暗示网络问题或其他故障。 10. unroutable (drop)（表示未被接收，且已经删除了的消息） 定义：显示由于无法路由而被删除的消息数量。 用途：用于监测消息路由过程中的问题，例如交换器或队列配置错误导致消息无法正确传递。 11. deliver&#x2F;get（消息消费者获取消息的速率） 定义：表示消费者获取消息的速度。 用途：评估消费者的消息接收能力，与生产者的发送速率相结合，以确保系统的平衡和高效运行。 12. ack（消息消费者 ack 消息的速率） 定义：消费者确认消息的速度。 用途：反映消费者对消息处理的及时性和可靠性，高确认速率有助于确保消息被正确处理并释放系统资源。 Exchanges（交换器）配置Name（名称） 定义：为交换器指定一个唯一的名称。 用途：在生产者和消费者的代码中引用该交换器，以便将消息路由到正确的目的地。 Type（类型） 常见类型及含义： direct：直连交换器，根据消息的路由键将消息路由到与该路由键完全匹配的队列。 topic：主题交换器，路由键可以包含通配符，根据路由键的模式匹配将消息路由到多个队列。 fanout：扇出交换器，将消息广播到所有绑定到该交换器的队列，不关心路由键。 headers：根据消息的头部属性进行路由，而不是路由键。 用途：不同类型适用于不同的消息路由需求场景。 Durability（持久性） 定义：如果设置为持久化，交换器在 RabbitMQ 服务器重启后仍然存在。 用途：确保重要的交换器不会因为服务器故障而丢失，保证消息路由的稳定性。 Auto-delete（自动删除） 定义：当最后一个绑定到该交换器的队列被解绑时，自动删除这个交换器。 用途：适用于临时的或者自动清理不再使用的交换器，节省系统资源。 Internal（内部交换器） 定义：内部交换器不能被客户端直接使用，只能用于在 RabbitMQ 内部进行消息路由。 用途：通常用于特殊的架构设计或者内部系统集成。 Arguments（参数） 定义：可以为交换器设置一些自定义的参数，具体含义取决于 RabbitMQ 的插件或者特定的使用场景。 用途：提供扩展和定制交换器行为的方式。 Queues（队列）配置Auto expire（自动过期时间） 定义：指定队列在没有任何活动的情况下，经过设定的时间后自动被删除。 用途：用于临时队列或自动清理不再使用的队列，节省系统资源。 Message TTL（消息生存时间） 定义：设置单个消息在队列中的存活时间，超时后会被自动移除或发送到死信队列。 用途：处理有时效性要求的消息。 Overflow behaviour（溢出行为） 定义：决定当队列已满时，新进入的消息如何处理。 取值及含义： Reject new publish：拒绝新消息的发布，发送者会收到错误响应。 Reject new publish&#x2F;dlx：拒绝新消息的发布，并将其发送到死信交换器（如果配置了死信交换器）。 Drop oldest&#x2F;newest publish：丢弃最早或最新的消息，以腾出空间给新消息。 Single active consumer（单个活动消费者） 定义：队列只允许一个消费者处于活动状态并接收消息。 用途：确保消息按特定顺序被单个消费者处理，避免多个消费者同时处理可能导致的冲突。 Dead letter exchange（死信交换器） 定义：当消息满足特定条件时，会被发送到这个指定的交换器。 用途：处理无法正常处理的消息，进行重试、记录错误等后续处理操作。 Dead letter routing key（死信路由键） 定义：与死信交换器一起使用，确定消息被发送到死信交换器后的路由方式。 Max length（最大长度） 定义：限制队列中可以存储的消息数量上限。 用途：防止队列无限增长导致内存耗尽等问题。 Max length bytes（最大字节数） 定义：限制队列中所有消息的总字节数上限。 Leader locator（领导者定位器） 定义：在 RabbitMQ 的集群环境中，确定队列的领导者所在的节点。 用途：帮助管理队列在集群中的分布和高可用性。","path":"2024/09/25/RabbitMQ-Web-界面配置解析/","date":"09-25","excerpt":"","tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://wanwan-doudou/github.io/tags/RabbitMQ/"}]},{"title":"解决 Python 异步 Socket 服务器消息堆积问题","text":"问题描述在开发一个 Python 异步 Socket 服务器时，遇到了消息堆积的问题。服务器包含一个 TCP 服务和一个键盘监听服务。当检测到特定的键盘操作时，服务器应该通过 TCP 向客户端发送消息。然而，这些消息并没有立即发送出去，而是在心跳消息发送时才一起发出，导致消息堆积。 原始代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960### socket_server.py```pythonimport asyncioimport socketSERVER_ADDRESS = &#x27;0.0.0.0&#x27;SERVER_PORT = 12345client_socket = Noneasync def handle_client(socket, client_address): global client_socket print(f&quot;设备已连接: &#123;client_address&#125;&quot;) client_socket = socket loop = asyncio.get_event_loop() try: while True: message = await loop.sock_recv(client_socket, 1024) if not message: break message = message.decode() print(f&quot;收到消息: &#123;message&#125;&quot;) if message == &quot;HEARTBEAT&quot;: print(&quot;收到心跳消息&quot;) continue reply = f&quot;服务器收到: &#123;message&#125;&quot; await loop.sock_sendall(client_socket, reply.encode()) await asyncio.sleep(0) print(f&quot;发送回复: &#123;reply&#125;&quot;) except ConnectionResetError: print(&quot;连接已关闭&quot;) finally: client_socket = None socket.close()async def send_message(client_socket, message): print(f&quot;准备发送消息: &#123;message&#125;&quot;) loop = asyncio.get_event_loop() try: await loop.sock_sendall(client_socket, message.encode()) print(f&quot;消息发送成功: &#123;message&#125;&quot;) except Exception as e: print(f&quot;发送消息出错: &#123;e&#125;&quot;)async def start_server(): server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_socket.bind((SERVER_ADDRESS, SERVER_PORT)) server_socket.listen(1) print(&quot;等待设备连接&quot;) loop = asyncio.get_event_loop() server_socket.setblocking(False) while True: client_socket, client_address = await loop.sock_accept(server_socket) await asyncio.create_task(handle_client(client_socket, client_address)) keyboard_listener.py (部分代码)12345async def process_messages(): while True: message = await message_queue.get() if socket_server.client_socket is not None: await socket_server.send_message(socket_server.client_socket, message) 原始代码中的问题 send_message 函数没有在消息末尾添加换行符，可能导致客户端无法正确分割消息。 handle_client 函数在发送回复后使用了 await asyncio.sleep(0)，这可能导致不必要的延迟。 process_messages 函数没有在处理完一条消息后让出控制权给事件循环。 解决方案1. 修改 send_message 函数在 socket_server.py 中，将 send_message 函数修改如下： 12345678async def send_message(client_socket, message): print(f&quot;准备发送消息: &#123;message&#125;&quot;) loop = asyncio.get_running_loop() try: await loop.sock_sendall(client_socket, (message + &#x27;\\n&#x27;).encode()) print(f&quot;消息发送成功: &#123;message&#125;&quot;) except Exception as e: print(f&quot;发送消息出错: &#123;e&#125;&quot;) 2. 优化 handle_client 函数在 socket_server.py 中，修改 handle_client 函数： 12345678910111213141516171819202122232425async def handle_client(socket, client_address): global client_socket print(f&quot;设备已连接: &#123;client_address&#125;&quot;) client_socket = socket loop = asyncio.get_running_loop() try: while True: message = await loop.sock_recv(client_socket, 1024) if not message: break message = message.decode().strip() # 去除可能的换行符 print(f&quot;收到消息: &#123;message&#125;&quot;) if message == &quot;HEARTBEAT&quot;: print(&quot;收到心跳消息&quot;) continue reply = f&quot;服务器收到: &#123;message&#125;&quot; await send_message(client_socket, reply) except ConnectionResetError: print(&quot;连接已关闭&quot;) finally: client_socket = None socket.close() 3. 优化 process_messages 函数在 keyboard_listener.py 中，修改 process_messages 函数： 123456async def process_messages(): while True: message = await message_queue.get() if socket_server.client_socket is not None: await socket_server.send_message(socket_server.client_socket, message) await asyncio.sleep(0) # 让出控制权给事件循环 结论通过以上修改，解决了消息堆积的问题，使服务器能够及时将消息发送给客户端。关键改进包括： 在发送消息时添加换行符，确保客户端能正确接收和分割消息。 移除了 handle_client 函数中不必要的 asyncio.sleep(0)。 在 process_messages 函数中添加了 await asyncio.sleep(0)，以确保在处理完一条消息后让出控制权。 确保所有异步操作都正确使用 await。 这是修改后完整的代码12345678910111213141516171819202122232425262728# main.pyimport asyncioimport keyboard_listenerimport socket_serverasync def main(): # 启动TCP服务器 server_task = asyncio.create_task(socket_server.start_server()) # 启动键盘监听器 listener_task = asyncio.create_task(keyboard_listener.start_listener()) # 启动消息处理任务 message_task = asyncio.create_task(keyboard_listener.process_messages()) # 保持主线程运行，直到所有任务完成 await asyncio.gather( server_task, listener_task, message_task )if __name__ == &quot;__main__&quot;: asyncio.run(main()) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# socket_server.pyimport asyncioimport socketSERVER_ADDRESS = &#x27;0.0.0.0&#x27; # 监听所有IP地址SERVER_PORT = 12345client_socket = None # 全局变量保存唯一的客户端连接async def handle_client(socket, client_address): global client_socket print(f&quot;设备已连接: &#123;client_address&#125;&quot;) client_socket = socket # 保存客户端连接 loop = asyncio.get_running_loop() try: while True: message = await loop.sock_recv(client_socket, 1024) if not message: break message = message.decode().strip() # 去除可能的换行符 print(f&quot;收到消息: &#123;message&#125;&quot;) # 处理心跳消息 if message == &quot;HEARTBEAT&quot;: print(&quot;收到心跳消息&quot;) continue # 处理其他消息 reply = f&quot;服务器收到: &#123;message&#125;&quot; await send_message(client_socket, reply) except ConnectionResetError: print(&quot;连接已关闭&quot;) finally: client_socket = None # 客户端断开时重置全局变量 socket.close()async def send_message(client_socket, message): print(f&quot;准备发送消息: &#123;message&#125;&quot;) loop = asyncio.get_running_loop() try: await loop.sock_sendall(client_socket, (message + &#x27;\\n&#x27;).encode()) print(f&quot;消息发送成功: &#123;message&#125;&quot;) except Exception as e: print(f&quot;发送消息出错: &#123;e&#125;&quot;)async def start_server(): server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_socket.bind((SERVER_ADDRESS, SERVER_PORT)) server_socket.listen(1) print(&quot;等待设备连接&quot;) loop = asyncio.get_event_loop() server_socket.setblocking(False) while True: client_socket, client_address = await loop.sock_accept(server_socket) await asyncio.create_task(handle_client(client_socket, client_address)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# keyboard_listener.pyimport asynciofrom pynput import keyboardimport socket_server# 初始化变量，用于跟踪Ctrl键的状态和按下c键的次数is_ctrl_pressed = Falsec_press_count = 0message_queue = asyncio.Queue() # 创建消息队列def on_press(key, loop): &quot;&quot;&quot; 按键按下时调用的函数 &quot;&quot;&quot; global is_ctrl_pressed, c_press_count # 声明使用全局变量 # 检测左ctrl或右ctrl键按下 if key == keyboard.Key.ctrl_l or key == keyboard.Key.ctrl_r: is_ctrl_pressed = True # 设置Ctrl键状态为按下 # 如果ctrl键被按住，检测c键按下 elif is_ctrl_pressed and hasattr(key, &#x27;char&#x27;): # 检测 Ctrl + c 的组合 if key.char == &#x27;\\x03&#x27;: # &#x27;\\x03&#x27; 是 Ctrl + c 的控制字符 c_press_count += 1 # 计数器增加 if c_press_count == 3: c_press_count = 0 # 达到三次后重置计数器 print(&quot;我按住ctrl然后连续按了三次c&quot;) if socket_server.client_socket is not None: # 确保client_socket不为None print(&quot;确保client_socket不为None&quot;) asyncio.run_coroutine_threadsafe( message_queue.put(&quot;123456789&quot;), # 将消息放入队列 loop )def on_release(key): &quot;&quot;&quot; 按键释放时调用的函数 &quot;&quot;&quot; global is_ctrl_pressed, c_press_count # 声明使用全局变量 # 检测左ctrl或右ctrl键释放 if key == keyboard.Key.ctrl_l or key == keyboard.Key.ctrl_r: is_ctrl_pressed = False # 设置Ctrl键状态为释放 c_press_count = 0 # 重置计数器def start_listener_sync(loop): &quot;&quot;&quot; 启动键盘监听器（同步方式） &quot;&quot;&quot; listener = keyboard.Listener(on_press=lambda key: on_press(key, loop), on_release=on_release) # 创建监听器 listener.start() # 启动监听器 listener.join() # 等待监听器线程结束async def start_listener(): &quot;&quot;&quot; 启动键盘监听器（异步方式） &quot;&quot;&quot; loop = asyncio.get_running_loop() await loop.run_in_executor(None, start_listener_sync, loop)async def process_messages(): while True: message = await message_queue.get() # 从队列中获取消息 if socket_server.client_socket is not None: await socket_server.send_message(socket_server.client_socket, message) await asyncio.sleep(0.1) # 添加短暂延迟，让其他协程有机会运行 这是前端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.aijiang.myapplication;import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.net.SocketTimeoutException;import android.util.Log;// TcpClient.javapublic class TcpClient &#123; private static final String TAG = &quot;TcpClient&quot;; private String serverAddress; private int serverPort; private Socket socket; private PrintWriter out; private BufferedReader in; // 构造函数，初始化服务器地址和端口 public TcpClient(String serverAddress, int serverPort) &#123; this.serverAddress = serverAddress; this.serverPort = serverPort; &#125; // 连接到服务器 public void connect() throws Exception &#123; Log.v(TAG, &quot;Connecting to server...&quot;); socket = new Socket(serverAddress, serverPort); out = new PrintWriter(socket.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); Log.v(TAG, &quot;Connected to server.&quot;); &#125; // 向服务器发送消息 public void sendMessage(String message) &#123; if (out != null &amp;&amp; !out.checkError()) &#123; Log.v(TAG, &quot;Sending message: &quot; + message); out.println(message); out.flush(); &#125; &#125; // 接收来自服务器的消息 public String receiveMessage() throws Exception &#123; socket.setSoTimeout(60000); // 设置超时时间为60秒，可以根据需求调整 if (in != null) &#123; String response; try &#123; response = in.readLine(); if (response != null) &#123; Log.v(TAG, &quot;我接受到的消息 message: &quot; + response); return response; &#125; else &#123; Log.v(TAG, &quot;No message received.&quot;); &#125; &#125; catch (SocketTimeoutException e) &#123; Log.v(TAG, &quot;Socket timeout, no message received.&quot;); // 这里可以发送心跳包 sendMessage(&quot;HEARTBEAT&quot;); // 发送心跳消息 &#125; &#125; return null; &#125; // 关闭连接 public void close() throws Exception &#123; if (socket != null) &#123; socket.close(); &#125; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.aijiang.myapplication;import android.os.Bundle;import android.util.Log;import android.widget.TextView;import androidx.activity.EdgeToEdge;import androidx.appcompat.app.AppCompatActivity;import androidx.core.graphics.Insets;import androidx.core.view.ViewCompat;import androidx.core.view.WindowInsetsCompat;import java.net.SocketTimeoutException;public class MainActivity extends AppCompatActivity &#123; private static final String TAG = &quot;MainActivity&quot;; private static final String SERVER_ADDRESS = &quot;192.168.43.57&quot;; private static final int SERVER_PORT = 12345; private static final int HEARTBEAT_INTERVAL = 30000; // 30秒发送一次心跳 private TextView textView; // 用于显示服务器回复的TextView private TcpClient tcpClient; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); EdgeToEdge.enable(this); setContentView(R.layout.activity_main); ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123; Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars()); v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom); return insets; &#125;); textView = findViewById(R.id.textView); // 初始化TextView // 开始连接服务器 new Thread(new TcpClientTask()).start(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); try &#123; if (tcpClient != null) &#123; tcpClient.close(); &#125; &#125; catch (Exception e) &#123; Log.e(TAG, &quot;Error closing TcpClient&quot;, e); &#125; &#125; private class TcpClientTask implements Runnable &#123; @Override public void run() &#123; tcpClient = new TcpClient(SERVER_ADDRESS, SERVER_PORT); try &#123; tcpClient.connect(); tcpClient.sendMessage(&quot;Hello, Server!&quot;); String response = tcpClient.receiveMessage(); if (response != null) &#123; Log.v(TAG, &quot;初始化连接时接收到的值: &quot; + response); runOnUiThread(() -&gt; &#123; textView.setText(response); // 更新TextView的文本 &#125;); &#125; else &#123; Log.d(TAG, &quot;No response from server&quot;); runOnUiThread(() -&gt; &#123; textView.setText(&quot;No response from server&quot;); &#125;); &#125; // 启动心跳线程 new Thread(new HeartbeatTask()).start(); // 保持连接状态，不关闭 while (true) &#123; try &#123; String serverMessage = tcpClient.receiveMessage(); if (serverMessage != null) &#123; Log.v(TAG, &quot;后续收到的消息: &quot; + serverMessage); runOnUiThread(() -&gt; &#123; // 如果包含多个消息，拆分并逐个显示 for (String msg : serverMessage.split(&quot;服务器收到: &quot;)) &#123; if (!msg.isEmpty()) &#123; textView.append(&quot;\\n&quot; + msg); // 更新TextView的文本 &#125; &#125; &#125;); &#125; &#125; catch (SocketTimeoutException e) &#123; Log.v(TAG, &quot;Socket timeout, no message received.&quot;); // 这里可以处理超时逻辑，但不要发送心跳消息 &#125; catch (Exception e) &#123; Log.e(TAG, &quot;Error receiving message&quot;, e); // 处理重连逻辑 &#125; &#125; &#125; catch (Exception e) &#123; Log.e(TAG, &quot;Error in TcpClientTask&quot;, e); &#125; &#125; &#125; private class HeartbeatTask implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(HEARTBEAT_INTERVAL); if (tcpClient != null) &#123; tcpClient.sendMessage(&quot;HEARTBEAT&quot;); Log.v(TAG, &quot;发送心跳消息&quot;); &#125; &#125; catch (InterruptedException e) &#123; Log.e(TAG, &quot;Heartbeat interval interrupted&quot;, e); &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021&lt;!-- activity_main.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415161718192021222324252627282930&lt;!-- AndroidManifest.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;!-- 添加网络权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot; android:fullBackupContent=&quot;@xml/backup_rules&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.MyApplication&quot; tools:targetApi=&quot;31&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;","path":"2024/09/11/解决-Python-异步-Socket-服务器消息堆积问题/","date":"09-11","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"}]},{"title":"go处理JSON数据","text":"在Go语言中，处理JSON数据通常使用标准库中的 encoding/json 包。以下是一些常用的操作方法： 一、基本操作1.将Go结构体编码为JSONjson.Marshal 方法将Go结构体转换为JSON字节流。如果需要格式化输出，可以使用 json.MarshalIndent。 123456789101112131415type Person struct &#123; Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;` &#125; func main() &#123; // 将Go结构体编码为JSON person := Person&#123;Name: &quot;aiJiang&quot;, Age: 22&#125; jsonData, err := json.Marshal(person) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(string(jsonData)) &#125; 12345678910func main() &#123; // 将Go结构体编码为JSON person := Person&#123;Name: &quot;aiJiang&quot;, Age: 22&#125; jsonData, err := json.MarshalIndent(person, &quot;&quot;, &quot; &quot;) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(string(jsonData)) &#125; 这是运行结果 2.将JSON解码为Go结构体 12345678910111213141516type Person struct &#123; Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;` &#125; func main() &#123; // 将JSON解码为Go结构体 jsonData := `&#123;&quot;name&quot;:&quot;AI&quot;, &quot;age&quot;:30&#125;` var p Person err := json.Unmarshal([]byte(jsonData), &amp;p) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(&quot;%+v\\n&quot;, p) &#125; json.Unmarshal 方法将JSON字节流解析为Go结构体。 这是运行结果 二、处理复杂JSON结构1. 处理嵌套结构 123456789101112131415161718192021type Address struct &#123; City string `json:&quot;city&quot;` ZipCode string `json:&quot;zip_code&quot;` &#125; type Person struct &#123; Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;` Address Address `json:&quot;address&quot;` &#125; func main() &#123; jsonData := `&#123;&quot;name&quot;:&quot;aiJiang&quot;, &quot;age&quot;:22, &quot;address&quot;:&#123;&quot;city&quot;:&quot;changsha&quot;, &quot;zip_code&quot;:&quot;410000&quot;&#125;&#125;` var p Person err := json.Unmarshal([]byte(jsonData), &amp;p) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(&quot;%+v\\n&quot;, p) &#125; 这是运行结果 2. 处理动态或未知结构使用 map[string]interface&#123;&#125; 或 interface&#123;&#125; 来处理结构不确定的JSON数据。 12345678910func main() &#123; jsonData := `&#123;&quot;name&quot;:&quot;aiJiang&quot;, &quot;age&quot;:22, &quot;additional_info&quot;:&#123;&quot;hobbies&quot;:[&quot;play table tennis&quot;, &quot;Program&quot;], &quot;is_student&quot;:false&#125;&#125;` var result map[string]interface&#123;&#125; err := json.Unmarshal([]byte(jsonData), &amp;result) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(&quot;%+v\\n&quot;, result) &#125; 这是运行结果 三、使用自定义的JSON标签可以通过在结构体字段上使用 json 标签来控制JSON的编码和解码行为。 1234567891011121314151617181920type Person struct &#123; Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;` Nickname string `json:&quot;nickname,omitempty&quot;` // omitempty表示为空时省略字段 Password string `json:&quot;-&quot;` // &quot;-&quot;表示忽略字段 &#125; func main() &#123; person := Person&#123; Name: &quot;aiJiang&quot;, Age: 22, Password: &quot;123456&quot;, &#125; jsonData, err := json.Marshal(person) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(string(jsonData)) &#125; 这是运行结果 四、流式编码和解码对于处理大数据集或需要逐条处理JSON对象的情况，可以使用 json.Encoder 和 json.Decoder。以下是一些使用流式编解码的场景： 大型数据集处理：当数据集太大，无法一次性加载到内存中时，可以使用流式编解码逐块读取或写入数据。 网络传输：在网络应用中，流式编解码允许你边接收数据边解析，或者边生成数据边发送，这样可以减少内存占用并提高响应速度。 实时数据处理：在需要实时处理数据的应用中，如日志分析或实时监控系统，流式编解码可以边读取数据边进行处理，而不需要等待整个数据集加载完成。 逐条处理JSON对象：在处理JSON格式的数据流时，如果数据以对象的形式逐个出现，使用流式编解码可以逐个对象进行处理，而不是将整个数据集加载到内存中。 节省内存：对于内存敏感的应用，流式编解码可以减少内存使用，因为它不需要一次性加载整个数据集。 异步处理：在异步编程模型中，流式编解码可以与异步IO操作配合使用，提高程序的并发性能。 数据转换：在需要将一种数据格式转换为另一种格式的过程中，流式编解码可以在转换过程中逐步处理数据，而不是将整个数据集加载到内存中进行转换。1234567891011121314151617181920212223func main() &#123; // 流式编码 enc := json.NewEncoder(os.Stdout) p := Person&#123;Name: &quot;aiJiang&quot;, Age: 22&#125; fmt.Print(&quot;Encoded JSON: &quot;) err := enc.Encode(p) if err != nil &#123; return &#125; // 注意：Encode会自动在输出的JSON后面加上一个换行符 // 准备要解码的JSON数据 data := `&#123;&quot;name&quot;:&quot;dou&quot;,&quot;age&quot;:23&#125;` dec := json.NewDecoder(strings.NewReader(data)) // 流式解码 var p2 Person err = dec.Decode(&amp;p2) if err != nil &#123; fmt.Println(&quot;Error decoding JSON:&quot;, err) return &#125; fmt.Printf(&quot;Decoded struct: %+v\\n&quot;, p2) &#125; 这是运行结果","path":"2024/09/05/go处理JSON数据/","date":"09-05","excerpt":"","tags":[{"name":"go","slug":"go","permalink":"https://wanwan-doudou/github.io/tags/go/"}]},{"title":"FinalShell激活","text":"友情提示1、此方去仅用于学习、测试 2、请购买正版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.bouncycastle.jce.provider.BouncyCastleProvider;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.Security;import java.util.Scanner;import java.util.List;import java.util.Arrays;import java.util.stream.Collectors;import java.util.stream.IntStream;public class FinalShellUtil &#123; static &#123; Security.addProvider(new BouncyCastleProvider()); &#125; public static void main(String[] args) &#123; Scanner inputScanner = new Scanner(System.in); System.out.print(&quot;输入机器码: &quot;); String machineCode = inputScanner.nextLine(); inputScanner.close(); System.out.println(&quot;版本号 &lt; 3.9.6 (旧版)&quot;); try &#123; MessageDigest md5Digest = MessageDigest.getInstance(&quot;MD5&quot;); List&lt;String&gt; legacyVersions = Arrays.asList(&quot;61305&quot; + machineCode + &quot;8552&quot;, &quot;2356&quot; + machineCode + &quot;13593&quot;); legacyVersions.stream() .map(version -&gt; md5Digest.digest(version.getBytes(StandardCharsets.UTF_8))) .map(FinalShellUtil::convertToHex) .map(hex -&gt; hex.substring(8, 24)) .forEach(hex -&gt; System.out.println(&quot;版本: &quot; + hex)); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;版本号 &gt;= 3.9.6 (新版)&quot;); try &#123; MessageDigest keccak384Digest = MessageDigest.getInstance(&quot;Keccak-384&quot;); List&lt;String&gt; newVersions = Arrays.asList(machineCode + &quot;hSf(78cvVlS5E&quot;, machineCode + &quot;FF3Go(*Xvbb5s2&quot;); newVersions.stream() .map(version -&gt; keccak384Digest.digest(version.getBytes(StandardCharsets.UTF_8))) .map(FinalShellUtil::convertToHex) .map(hex -&gt; hex.substring(12, 28)) .forEach(hex -&gt; System.out.println(&quot;版本: &quot; + hex)); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; &#125; private static String convertToHex(byte[] byteArray) &#123; return IntStream.range(0, byteArray.length) .mapToObj(i -&gt; String.format(&quot;%02x&quot;, byteArray[i])) .collect(Collectors.joining()); &#125;&#125;","path":"2024/08/02/FinalShell激活/","date":"08-02","excerpt":"","tags":[{"name":"破解","slug":"破解","permalink":"https://wanwan-doudou/github.io/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"Vue项目启动报错“error:0308010C:digital envelope routines::unsupported解决办法”","text":"Vue报错error:0308010C:digital envelope routines::unsupported在package.json增加配置1234&quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;set NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot; &#125;,","path":"2023/04/24/Vue项目启动报错“error-0308010C-digital-envelope-routines-unsupported解决办法”/","date":"04-24","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"https://wanwan-doudou/github.io/tags/vue/"}]},{"title":"java爬虫 403_使用java爬虫获取网络资源403错误解决","text":"今天爬虫的时候下载爬到的URL时候报这个错误 Server returned HTTP response code: 403 for URL: 这个错误。 有可能是服务器拒绝了java直接访问。 所以需要使用下面选中的部分。伪装成浏览器请求。 123456URL url = new URL(imageUrl); URLConnection uc; uc = url.openConnection(); uc.addRequestProperty(&quot;User-Agent&quot;,&quot;Mozilla/4.0 (compatible; MSIE 6.0;WindowsNT 5.0)&quot;); uc.setDoInput(true);//设置是否要从 URL 连接读取数据,默认为true uc.connect();","path":"2022/12/20/java爬虫-403-使用java爬虫获取网络资源403错误解决/","date":"12-20","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://wanwan-doudou/github.io/tags/java/"}]},{"title":"HttpClient获取302响应中的Location头信息","text":"12345678910111213141516171819public static String getLocationUrl(String url) &#123; RequestConfig config = RequestConfig.custom().setConnectTimeout(50000).setConnectionRequestTimeout(10000).setSocketTimeout(50000) .setRedirectsEnabled(false).build();//不允许重定向 CloseableHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(config).build(); String location = null; int responseCode = 0; HttpResponse response; try &#123; response = httpClient.execute(new HttpGet(url)); responseCode = response.getStatusLine().getStatusCode(); if (responseCode == 302) &#123; Header locationHeader = response.getFirstHeader(&quot;Location&quot;); location = locationHeader.getValue(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return location; &#125;","path":"2022/12/18/HttpClient获取302响应中的Location头信息/","date":"12-18","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://wanwan-doudou/github.io/tags/java/"}]},{"title":"Vuex持久化插件(vuex-persistedstate)","text":"这篇文章主要介绍了Vuex持久化插件(vuex-persistedstate)-解决刷新数据消失的问题今天写项目的时候遇到一个问题，我刷新页面数据丢失在F5刷新页面后，vuex会重新更新state，所以，存储的数据会丢失。 vuex可以进行全局的状态管理，但刷新后刷新后数据会消失，这是我们不愿意看到的。怎么解决呢，我们可以结合本地存储做到数据持久化，也可以通过插件-vuex-persistedstate。 使用步骤 首先：我们需要安装一个vuex的插件 vuex-persistedstate 来支持vuex的状态持久化 1npm i vuex-persistedstate 在 src/store/index.js 中导入 createPersistedState 模块。 12// 引入vuex持久化方法createPersistedState import createPersistedState from &#x27;vuex-persistedstate&#x27; 最后：使用vuex-persistedstate插件来进行持久化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import vue from &#x27;vue&#x27; import Vuex from &#x27;vuex&#x27; import router, &#123;resetRouter&#125; from &quot;../router&quot;; // 引入vuex持久化方法createPersistedState import createPersistedState from &#x27;vuex-persistedstate&#x27; vue.use(Vuex) function addNewRoute(menuList) &#123; let routes = router.options.routes console.log(routes) routes.forEach(routeItem =&gt; &#123; if (routeItem.path == &quot;/Index&quot;) &#123; menuList.forEach(menu =&gt; &#123; let childRoute = &#123; path: &#x27;/&#x27; + menu.menuclick, name: menu.menuname, meta: &#123; title: menu.menuname &#125;, component: () =&gt; import(&#x27;../components/&#x27; + menu.menucomponent) &#125; routeItem.children.push(childRoute) &#125;) &#125; &#125;) resetRouter() router.addRoutes(routes) &#125; export default new Vuex.Store(&#123; state: &#123; menu: [] &#125;, mutations: &#123; setMenu(state, menuList) &#123; state.menu = menuList //添加路由 addNewRoute(menuList) &#125; &#125;, getters: &#123; getMenu(state) &#123; return state.menu &#125; &#125;, plugins: [ createPersistedState() ] &#125;)","path":"2022/12/15/Vuex持久化插件-vuex-persistedstate/","date":"12-15","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"https://wanwan-doudou/github.io/tags/vue/"}]},{"title":"element ui中的el-dropdown（下拉框）防止点一下就隐藏的问题","text":"在使用el-dropdown下拉框时，下拉框的每项中，可能需要加入@click、@change或复选框等事件，而el-dropdown-item的事件触发时，el-dropdown下拉框总是会收缩，很不合理。 这是官方例子 123456789101112&lt;el-dropdown&gt; &lt;span class=&quot;el-dropdown-link&quot;&gt; 下拉菜单&lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item&gt;黄金糕&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;狮子头&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;螺蛳粉&lt;/el-dropdown-item&gt; &lt;el-dropdown-item disabled&gt;双皮奶&lt;/el-dropdown-item&gt; &lt;el-dropdown-item divided&gt;蚵仔煎&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; 这个时候我们只需要在下拉属性中将 “hide-on-click” 属性设置为 false就好 1&lt;el-dropdown trigger=&quot;click&quot; :hide-on-click=&quot;false&quot;&gt;","path":"2022/12/08/element-ui中的el-dropdown（下拉框）防止点一下就隐藏的问题/","date":"12-08","excerpt":"","tags":[{"name":"elementUI","slug":"elementUI","permalink":"https://wanwan-doudou/github.io/tags/elementUI/"}]},{"title":"python实现爱心特效","text":"先看效果图 下面附上源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185# 晚上星月争辉，美梦陪你入睡import randomfrom math import sin, cos, pi, logfrom tkinter import *CANVAS_WIDTH = 640 # 画布的宽CANVAS_HEIGHT = 480 # 画布的高CANVAS_CENTER_X = CANVAS_WIDTH / 2 # 画布中心的X轴坐标CANVAS_CENTER_Y = CANVAS_HEIGHT / 2 # 画布中心的Y轴坐标IMAGE_ENLARGE = 11 # 放大比例HEART_COLOR = &quot;#ff2121&quot; # 心的颜色，这个是中国红def heart_function(t, shrink_ratio: float = IMAGE_ENLARGE): &quot;&quot;&quot; “爱心函数生成器” :param shrink_ratio: 放大比例 :param t: 参数 :return: 坐标 &quot;&quot;&quot; # 基础函数 x = 16 * (sin(t) ** 3) y = -(13 * cos(t) - 5 * cos(2 * t) - 2 * cos(3 * t) - cos(4 * t)) # 放大 x *= shrink_ratio y *= shrink_ratio # 移到画布中央 x += CANVAS_CENTER_X y += CANVAS_CENTER_Y return int(x), int(y)def scatter_inside(x, y, beta=0.15): &quot;&quot;&quot; 随机内部扩散 :param x: 原x :param y: 原y :param beta: 强度 :return: 新坐标 &quot;&quot;&quot; ratio_x = - beta * log(random.random()) ratio_y = - beta * log(random.random()) dx = ratio_x * (x - CANVAS_CENTER_X) dy = ratio_y * (y - CANVAS_CENTER_Y) return x - dx, y - dydef shrink(x, y, ratio): &quot;&quot;&quot; 抖动 :param x: 原x :param y: 原y :param ratio: 比例 :return: 新坐标 &quot;&quot;&quot; force = -1 / (((x - CANVAS_CENTER_X) ** 2 + (y - CANVAS_CENTER_Y) ** 2) ** 0.6) # 这个参数... dx = ratio * force * (x - CANVAS_CENTER_X) dy = ratio * force * (y - CANVAS_CENTER_Y) return x - dx, y - dydef curve(p): &quot;&quot;&quot; 自定义曲线函数，调整跳动周期 :param p: 参数 :return: 正弦 &quot;&quot;&quot; # 可以尝试换其他的动态函数，达到更有力量的效果（贝塞尔？） return 2 * (2 * sin(4 * p)) / (2 * pi) class Heart: &quot;&quot;&quot; 爱心类 &quot;&quot;&quot; def __init__(self, generate_frame=20): self._points = set() # 原始爱心坐标集合 self._edge_diffusion_points = set() # 边缘扩散效果点坐标集合 self._center_diffusion_points = set() # 中心扩散效果点坐标集合 self.all_points = &#123;&#125; # 每帧动态点坐标 self.build(2000) self.random_halo = 1000 self.generate_frame = generate_frame for frame in range(generate_frame): self.calc(frame) def build(self, number): # 爱心 for _ in range(number): t = random.uniform(0, 2 * pi) # 随机不到的地方造成爱心有缺口 x, y = heart_function(t) self._points.add((x, y)) # 爱心内扩散 for _x, _y in list(self._points): for _ in range(3): x, y = scatter_inside(_x, _y, 0.05) self._edge_diffusion_points.add((x, y)) # 爱心内再次扩散 point_list = list(self._points) for _ in range(4000): x, y = random.choice(point_list) x, y = scatter_inside(x, y, 0.17) self._center_diffusion_points.add((x, y)) @staticmethod def calc_position(x, y, ratio): # 调整缩放比例 force = 1 / (((x - CANVAS_CENTER_X) ** 2 + (y - CANVAS_CENTER_Y) ** 2) ** 0.520) # 魔法参数 dx = ratio * force * (x - CANVAS_CENTER_X) + random.randint(-1, 1) dy = ratio * force * (y - CANVAS_CENTER_Y) + random.randint(-1, 1) return x - dx, y - dy def calc(self, generate_frame): ratio = 10 * curve(generate_frame / 10 * pi) # 圆滑的周期的缩放比例 halo_radius = int(4 + 6 * (1 + curve(generate_frame / 10 * pi))) halo_number = int( 3000 + 4000 * abs(curve(generate_frame / 10 * pi) ** 2)) all_points = [] # 光环 heart_halo_point = set() # 光环的点坐标集合 for _ in range(halo_number): t = random.uniform(0, 2 * pi) # 随机不到的地方造成爱心有缺口 x, y = heart_function(t, shrink_ratio=11.6) # 魔法参数 x, y = shrink(x, y, halo_radius) if (x, y) not in heart_halo_point: # 处理新的点 heart_halo_point.add((x, y)) x += random.randint(-14, 14) y += random.randint(-14, 14) size = random.choice((1, 2, 2)) all_points.append((x, y, size)) # 轮廓 for x, y in self._points: x, y = self.calc_position(x, y, ratio) size = random.randint(1, 3) all_points.append((x, y, size)) # 内容 for x, y in self._edge_diffusion_points: x, y = self.calc_position(x, y, ratio) size = random.randint(1, 2) all_points.append((x, y, size)) for x, y in self._center_diffusion_points: x, y = self.calc_position(x, y, ratio) size = random.randint(1, 2) all_points.append((x, y, size)) self.all_points[generate_frame] = all_points def render(self, render_canvas, render_frame): for x, y, size in self.all_points[render_frame % self.generate_frame]: render_canvas.create_rectangle( x, y, x + size, y + size, width=0, fill=HEART_COLOR)def draw(main: Tk, render_canvas: Canvas, render_heart: Heart, render_frame=0): render_canvas.delete(&#x27;all&#x27;) render_heart.render(render_canvas, render_frame) main.after(160, draw, main, render_canvas, render_heart, render_frame + 1) if __name__ == &#x27;__main__&#x27;: root = Tk() # 一个Tk canvas = Canvas(root, bg=&#x27;black&#x27;, height=CANVAS_HEIGHT, width=CANVAS_WIDTH) canvas.pack() heart = Heart() # 心 draw(root, canvas, heart) # 开始画画~ root.mainloop()","path":"2022/11/08/python实现爱心特效/","date":"11-08","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"}]},{"title":"npm修改源为国内阿里云源","text":"修改npm源地址 npm config set registry https://registry.npm.taobao.org 设置好之后可以通过运行npm config list查看是否配置成功 可以在registry字段下看到已经换成设置的阿里下载源，那么恭喜你配置成功了。","path":"2022/11/05/npm修改源为国内阿里云源/","date":"11-05","excerpt":"","tags":[{"name":"npm","slug":"npm","permalink":"https://wanwan-doudou/github.io/tags/npm/"}]},{"title":"Linux快速上传到git仓库","text":"添加文件至工作区 git add 文件名 (这里文件名可以使用点.) 把工作区文件提交到本地仓库 git commit -m 备注 把本地仓库内容上传至远程仓库 git push","path":"2022/11/04/Linux快速上传到git仓库/","date":"11-04","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"https://wanwan-doudou/github.io/tags/git/"}]},{"title":"centos8 上传 github","text":"1 安装git sudo apt install git 绑定GitHub用户 git config –global user.name “XXX”git config –global user.email &#120;&#x78;&#120;&#64;&#x78;&#120;&#x78;&#x2e;&#99;&#x6f;&#x6d; 查看用户信息 git config –list 2 生成SSH key ssh-keygen -t rsa -C &#120;&#x78;&#x78;&#64;&#120;&#120;&#120;&#46;&#x63;&#111;&#109; 生成的公钥信息会存在&#x2F;home&#x2F;XXX&#x2F;.ssh&#x2F;id_rsa.pub文件里，打开该文件，复制公钥信息。打开GitHub，进入个人主页-&gt;settings-&gt;SSH and GPG keys-&gt;New SSH key公钥名称可以自己设置，公钥信息即为刚才复制的文件全部内容 测试连接 ssh -T &#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#x6f;&#109; 3 创建本地仓库进入要上传的文件夹目录下，输入 git init 创建新仓库 （之后的操作要回到文件夹目录，不要在.git文件夹下面操作，不然会报错） 添加文件至工作区（工作区相当于一个缓存，存储还没有添加到本地仓库的文件）： git add 文件名 查看工作区文件： git status 把工作区文件提交到本地仓库 git commit -m 备注 查看本地仓库文件 git ls-files 关联远程仓库 git remote add 仓库名称 仓库的SSH链接 一般来说，每个远程仓库只要关联一次即可生效，如果想删除关联的远程仓库可以使用： git remote rm 仓库名称 查看已关联的远程仓库列表 git remote 把本地仓库内容上传至远程仓库 git push 远程仓库名称 远程仓库文件夹 如果远程仓库有过修改，和 本地仓库内容不一致，提交可能出现报错。此时解决方法： git pull -rebase 远程仓库名称 本地仓库文件夹（默认为master）","path":"2022/11/04/centos8-上传-github/","date":"11-04","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"https://wanwan-doudou/github.io/tags/git/"}]},{"title":"Python3 字符串","text":"Python3 字符串字符串是 Python 中最常用的数据类型。我们可以使用引号( ‘ 或 “ )来创建字符串。 创建字符串很简单，只要为变量分配一个值即可。例如 var1 &#x3D; ‘Hello World!’var2 &#x3D; “Runoob” Python 访问字符串中的值Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。 Python 访问子字符串，可以使用方括号 [] 来截取字符串，字符串的截取的语法格式如下： 变量[头下标:尾下标] 索引值以 0 为开始值，**-1** 为从末尾的开始位置。 如下实例： var1 &#x3D; ‘Hello World!’var2 &#x3D; “Runoob”print (“var1[0]: “, var1[0])print (“var2[1:5]: “, var2[1:5]) 以上实例执行结果： var1[0]: Hvar2[1:5]: unoo Python 字符串更新你可以截取字符串的一部分并与其他字段拼接，如下实例： var1 &#x3D; ‘Hello World!’print (“已更新字符串 : “, var1[:6] + ‘Runoob!’) 以上实例执行结果 已更新字符串 : Hello Runoob! Python转义字符在需要在字符中使用特殊字符时，python 用反斜杠 \\ 转义字符。如下表： 转义字符 描述 实例 (在行尾时) 续行符 \\ 反斜杠符号 &#39; 单引号 &quot; 双引号 \\a 响铃 \\b 退格(Backspace) \\000 空 \\n 换行 \\t 横向制表符 \\r 回车，将 \\r 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 \\r 后面的内容完全替换完成。 \\f 换页 Python字符串运算符下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”： 操作符 描述 实例 | 字符串连接 | a + b 输出结果： HelloPython | 重复输出字符串 | a*2 输出结果：HelloHello[] | 通过索引获取字符串中字符 | a[1] 输出结果 e[ : ] | 截取字符串中的一部分，遵循左闭右开原则，str[0:2] 是不包含第 3 个字符的。| a[1:4]输出结果 ellin | 成员运算符 - 如果字符串中包含给定的字符返回 True | ‘H’ in a 输出结果 Truenot in | 成员运算符 - 如果字符串中不包含给定的字符返回 True | ‘M’ not in a 输出结果 True 1234567891011121314151617a = &quot;Hello&quot;b = &quot;Python&quot;print(&quot;a + b 输出结果：&quot;, a + b) print(&quot;a * 2 输出结果：&quot;, a * 2)print(&quot;a[1] 输出结果：&quot;, a[1])print(&quot;a[1:4] 输出结果：&quot;, a[1:4])if( &quot;H&quot; in a) : print(&quot;H 在变量 a 中&quot;)else : print(&quot;H 不在变量 a 中&quot;) if( &quot;M&quot; not in a) : print(&quot;M 不在变量 a 中&quot;)else : print(&quot;M 在变量 a 中&quot;) 以上实例输出结果为： a + b 输出结果： HelloPythona * 2 输出结果： HelloHelloa[1] 输出结果： ea[1:4] 输出结果： ellH 在变量 a 中M 不在变量 a 中 Python 字符串格式化Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。 在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。 1print (&quot;我叫 %s 今年 %d 岁!&quot; % (&#x27;小明&#x27;, 10)) 以上实例输出结果： 我叫 小明 今年 10 岁! python字符串格式化符号: 符号 描述 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 Python三引号python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下 1234567para_str = &quot;&quot;&quot;这是一个多行字符串的实例多行字符串可以使用制表符TAB ( \\t )。也可以使用换行符 [ \\n ]。&quot;&quot;&quot;print (para_str) 这是一个多行字符串的实例多行字符串可以使用制表符TAB ( )。也可以使用换行符 [ ]。 f-stringf-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。 之前我们习惯用百分号 (%): &gt;&gt;&gt; name &#x3D; ‘Runoob’&gt;&gt;&gt; ‘Hello %s’ % name‘Hello Runoob’ f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下： &gt;&gt;&gt; name &#x3D; ‘Runoob’&gt;&gt;&gt; f’Hello {name}’ # 替换变量‘Hello Runoob’&gt;&gt;&gt; f’{1+2}’ # 使用表达式‘3’&gt;&gt;&gt; w &#x3D; {‘name’: ‘Runoob’, ‘url’: ‘www.runoob.com&#39;}&gt;&gt;&gt; f’{w[“name”]}: {w[“url”]}’‘Runoob: www.runoob.com‘ 用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。 在 Python 3.8 的版本中可以使用 &#x3D; 符号来拼接运算表达式与结果： &gt;&gt;&gt; x &#x3D; 1&gt;&gt;&gt; print(f’{x+1}’) # Python 3.62&gt;&gt;&gt; x &#x3D; 1&gt;&gt;&gt; print(f’{x+1&#x3D;}’) # Python 3.8x+1&#x3D;2","path":"2022/10/03/Python3-字符串/","date":"10-03","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"}]},{"title":"Python3 数字(Number)","text":"Python3 数字(Number)Python 数字数据类型用于存储数值。 数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。 以下实例在变量赋值时 Number 对象将被创建： var1 &#x3D; 1var2 &#x3D; 10 您也可以使用del语句删除一些数字对象的引用。 del语句的语法是： del var1[,var2[,var3[….,varN]]] 您可以通过使用del语句删除单个或多个对象的引用，例如： del vardel var_a, var_b Python 支持三种不同的数值类型： 整型(int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。 浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 &#x3D; 2.5 x 102 &#x3D; 250） 复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 &gt;&gt;&gt; number &#x3D; 0xA0F # 十六进制&gt;&gt;&gt; number2575&gt;&gt;&gt; number&#x3D;0o37 # 八进制&gt;&gt;&gt; number31 Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 Python 数字类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 int(x) 将x转换为一个整数。 float(x) 将x转换到一个浮点数。 complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。 complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。 &gt;&gt;&gt; a &#x3D; 1.0&gt;&gt;&gt; int(a)1 Python 数字运算Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。 表达式的语法很直白： +, -, * 和 &#x2F;, 和其它语言（如C）里一样。例如： &gt;&gt;&gt; 2 + 24&gt;&gt;&gt; 50 - 5620&gt;&gt;&gt; (50 - 56) &#x2F; 45.0&gt;&gt;&gt; 8 &#x2F; 5 # 总是返回一个浮点数1.6 注意：在不同的机器上浮点运算的结果可能会不一样。 在整数除法中，除法 &#x2F; 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 &#x2F;&#x2F; ： &gt;&gt;&gt; 17 &#x2F; 3 # 整数除法返回浮点型5.666666666666667&gt;&gt;&gt;&gt;&gt;&gt; 17 &#x2F;&#x2F; 3 # 整数除法返回向下取整后的结果5&gt;&gt;&gt; 17 % 3 # ％操作符返回除法的余数2&gt;&gt;&gt; 5 * 3 + 217 注意：&#x2F;&#x2F; 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。 &gt;&gt;&gt; 7&#x2F;&#x2F;23&gt;&gt;&gt; 7.0&#x2F;&#x2F;23.0&gt;&gt;&gt; 7&#x2F;&#x2F;2.03.0&gt;&gt;&gt; 等号 &#x3D; 用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何结果。 &gt;&gt;&gt; width &#x3D; 20&gt;&gt;&gt; height &#x3D; 5*9&gt;&gt;&gt; width * height900 Python 可以使用 ** 操作来进行幂运算： &gt;&gt;&gt; 5 ** 2 # 5 的平方25&gt;&gt;&gt; 2 ** 7 # 2的7次方128 变量在使用前必须先”定义”（即赋予变量一个值），否则会出现错误： &gt;&gt;&gt; n # 尝试访问一个未定义的变量Traceback (most recent call last): File “&lt; stdin &gt;”, line 1, in &lt; module &gt;NameError: name ‘n’ is not defined 不同类型的数混合运算时会将整数转换为浮点数： &gt;&gt;&gt; 3 * 3.75 &#x2F; 1.57.5&gt;&gt;&gt; 7.0 &#x2F; 23.5 在交互模式中，最后被输出的表达式结果被赋值给变量 _ 。例如： &gt;&gt;&gt; tax &#x3D; 12.5 &#x2F; 100&gt;&gt;&gt; price &#x3D; 100.50&gt;&gt;&gt; price * tax12.5625&gt;&gt;&gt; price + _113.0625&gt;&gt;&gt; round(_, 2)113.06 此处， _ 变量应被用户视为只读变量。 数学函数 函数 返回值（描述） abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1,x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1,x2…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x,y) x**y 运算后的值。 round(x[,n]) **返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。 sqrt(x) 返回数字x的平方根。 随机数函数随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。 Python包含以下常用随机数函数： 函数 返回值（描述） choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 random.randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 random() 随机生成下一个实数，它在[0,1)范围内。 shuffle(lst) 序列的所有元素随机排序 random.uniform(x, y) random.uniform(x, y)","path":"2022/10/01/Python3-数字-Number/","date":"10-01","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"}]},{"title":"win和fn键失效","text":"今天在使用电脑的时候突然发现电脑的win和fn键使用不了了 这个时候我们按住win+fn+num键就好了","path":"2022/10/01/win和fn键失效/","date":"10-01","excerpt":"","tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://wanwan-doudou/github.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"Python3 运算符","text":"Python 语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 接下来让我们一个个来学习Python的运算符。 Python算术运算符以下假设变量 a&#x3D;10，变量 b&#x3D;21： 运算符 描述 实例 | 加 - 两个对象相加 | a + b 输出结果 31 | 减 - 得到负数或是一个数减去另一个数 | a - b 输出结果 -11 | 乘 - 两个数相乘或是返回一个被重复若干次的字符串 | a * b 输出结果 210&#x2F; | 除 - x 除以 y | b &#x2F; a 输出结果 2.1% | 取模 - 返回除法的余数 | b % a 输出结果 1&#x2F;&#x2F;| 取整除 - 向下取接近商的整数 | 9&#x2F;&#x2F;2 &#x3D; 4,-9&#x2F;&#x2F;2 &#x3D; -5 以下实例演示了Python所有算术运算符的操作： 1234567891011121314151617181920212223242526272829303132a = 21b = 10c = 0c = a + bprint (&quot;1 - c 的值为：&quot;, c)c = a - bprint (&quot;2 - c 的值为：&quot;, c)c = a * bprint (&quot;3 - c 的值为：&quot;, c)c = a / bprint (&quot;4 - c 的值为：&quot;, c)c = a % bprint (&quot;5 - c 的值为：&quot;, c)# 修改变量 a 、b 、ca = 2b = 3c = a**bprint (&quot;6 - c 的值为：&quot;, c)a = 10b = 5c = a//bprint (&quot;7 - c 的值为：&quot;, c) 以上实例输出结果： 1 - c 的值为： 312 - c 的值为： 113 - c 的值为： 2104 - c 的值为： 2.15 - c 的值为： 16 - c 的值为： 87 - c 的值为： 2 Python比较运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 &#x3D;&#x3D; 等于 - 比较对象是否相等 a &#x3D;&#x3D; b) 返回 False。 !&#x3D; 不等于 - 比较两个对象是否不相等 (a !&#x3D; b) 返回 True。 | 大于 - 返回x是否大于y | (a &gt; b) 返回 False。&lt; | 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。| (a &lt; b) 返回 True。&#x3D; | 大于等于 - 返回x是否大于等于y。 | (a &gt;&#x3D; b) 返回 False。&lt;&#x3D; | 小于等于 - 返回x是否小于等于y。 | (a &lt;&#x3D; b) 返回 True。 以下实例演示了Python所有比较运算符的操作： 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/python3a = 21b = 10c = 0if ( a == b ): print (&quot;1 - a 等于 b&quot;)else: print (&quot;1 - a 不等于 b&quot;)if ( a != b ): print (&quot;2 - a 不等于 b&quot;)else: print (&quot;2 - a 等于 b&quot;)if ( a &lt; b ): print (&quot;3 - a 小于 b&quot;)else: print (&quot;3 - a 大于等于 b&quot;)if ( a &gt; b ): print (&quot;4 - a 大于 b&quot;)else: print (&quot;4 - a 小于等于 b&quot;)# 修改变量 a 和 b 的值a = 5b = 20if ( a &lt;= b ): print (&quot;5 - a 小于等于 b&quot;)else: print (&quot;5 - a 大于 b&quot;)if ( b &gt;= a ): print (&quot;6 - b 大于等于 a&quot;)else: print (&quot;6 - b 小于 a&quot;) 以上实例输出结果： 1 - c 的值为： 312 - c 的值为： 523 - c 的值为： 10924 - c 的值为： 52.05 - c 的值为： 26 - c 的值为： 20971527 - c 的值为： 99864 Python位运算符按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13二进制格式如下： a &#x3D; 0011 1100b &#x3D; 0000 1101a&amp;b &#x3D; 0000 1100a|b &#x3D; 0011 1101~a &#x3D; 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 以下实例演示了Python所有位运算符的操作： 123456789101112131415161718192021a = 60 # 60 = 0011 1100b = 13 # 13 = 0000 1101c = 0c = a &amp; b # 12 = 0000 1100print (&quot;1 - c 的值为：&quot;, c)c = a | b # 61 = 0011 1101print (&quot;2 - c 的值为：&quot;, c)c = a ^ b # 49 = 0011 0001print (&quot;3 - c 的值为：&quot;, c)c = ~a # -61 = 1100 0011print (&quot;4 - c 的值为：&quot;, c)c = a &lt;&lt; 2 # 240 = 1111 0000print (&quot;5 - c 的值为：&quot;, c)c = a &gt;&gt; 2 # 15 = 0000 1111print (&quot;6 - c 的值为：&quot;, c) 以上实例输出结果： 1 - c 的值为： 122 - c 的值为： 613 - c 的值为： 494 - c 的值为： -615 - c 的值为： 2406 - c 的值为： 15 Python逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 以上实例输出结果： 123456789101112131415161718192021222324252627282930a = 10b = 20if ( a and b ): print (&quot;1 - 变量 a 和 b 都为 true&quot;)else: print (&quot;1 - 变量 a 和 b 有一个不为 true&quot;)if ( a or b ): print (&quot;2 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;)else: print (&quot;2 - 变量 a 和 b 都不为 true&quot;)# 修改变量 a 的值a = 0if ( a and b ): print (&quot;3 - 变量 a 和 b 都为 true&quot;)else: print (&quot;3 - 变量 a 和 b 有一个不为 true&quot;) if ( a or b ): print (&quot;4 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;)else: print (&quot;4 - 变量 a 和 b 都不为 true&quot;) if not( a and b ): print (&quot;5 - 变量 a 和 b 都为 false，或其中一个变量为 false&quot;)else: print (&quot;5 - 变量 a 和 b 都为 true&quot;) 1 - 变量 a 和 b 都为 true2 - 变量 a 和 b 都为 true，或其中一个变量为 true3 - 变量 a 和 b 有一个不为 true4 - 变量 a 和 b 都为 true，或其中一个变量为 true5 - 变量 a 和 b 都为 false，或其中一个变量为 false Python成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 1234567891011121314151617181920a = 10b = 20list = [1, 2, 3, 4, 5 ]if ( a in list ): print (&quot;1 - 变量 a 在给定的列表中 list 中&quot;)else: print (&quot;1 - 变量 a 不在给定的列表中 list 中&quot;)if ( b not in list ): print (&quot;2 - 变量 b 不在给定的列表中 list 中&quot;)else: print (&quot;2 - 变量 b 在给定的列表中 list 中&quot;)# 修改变量 a 的值a = 2if ( a in list ): print (&quot;3 - 变量 a 在给定的列表中 list 中&quot;)else: print (&quot;3 - 变量 a 不在给定的列表中 list 中&quot;) 以上实例输出结果： 1 - 变量 a 不在给定的列表中 list 中2 - 变量 b 不在给定的列表中 list 中3 - 变量 a 在给定的列表中 list 中 Python身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) &#x3D;&#x3D; id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 **id(x) !&#x3D; id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id()函数用于获取对象内存地址。 以下实例演示了Python所有身份运算符的操作： 12345678910111213141516171819202122232425a = 20b = 20if ( a is b ): print (&quot;1 - a 和 b 有相同的标识&quot;)else: print (&quot;1 - a 和 b 没有相同的标识&quot;)if ( id(a) == id(b) ): print (&quot;2 - a 和 b 有相同的标识&quot;)else: print (&quot;2 - a 和 b 没有相同的标识&quot;)# 修改变量 b 的值b = 30if ( a is b ): print (&quot;3 - a 和 b 有相同的标识&quot;)else: print (&quot;3 - a 和 b 没有相同的标识&quot;)if ( a is not b ): print (&quot;4 - a 和 b 没有相同的标识&quot;)else: print (&quot;4 - a 和 b 有相同的标识&quot;) 以上实例输出结果： 1 - a 和 b 有相同的标识2 - a 和 b 有相同的标识3 - a 和 b 没有相同的标识4 - a 和 b 没有相同的标识 is 与 &#x3D;&#x3D; 区别： is 用于判断两个变量引用对象是否为同一个， &#x3D;&#x3D; 用于判断引用变量的值是否相等。 1234567891011&gt;&gt;&gt;a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b is aTrue&gt;&gt;&gt; b == aTrue&gt;&gt;&gt; b = a[:]&gt;&gt;&gt; b is aFalse&gt;&gt;&gt; b == aTrue Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符， 相同单元格内的运算符具有相同优先级。 运算符均指二元运算，除非特别指出。 相同单元格内的运算符从左至右分组（除了幂运算是从右至左分组）： 以下实例演示了Python所有运算符优先级的操作： 1234567891011121314151617a = 20b = 10c = 15d = 5e = 0e = (a + b) * c / d #( 30 * 15 ) / 5print (&quot;(a + b) * c / d 运算结果为：&quot;, e)e = ((a + b) * c) / d # (30 * 15 ) / 5print (&quot;((a + b) * c) / d 运算结果为：&quot;, e)e = (a + b) * (c / d) # (30) * (15/5)print (&quot;(a + b) * (c / d) 运算结果为：&quot;, e)e = a + (b * c) / d # 20 + (150/5)print (&quot;a + (b * c) / d 运算结果为：&quot;, e) 以上实例输出结果： (a + b) * c &#x2F; d 运算结果为： 90.0((a + b) * c) &#x2F; d 运算结果为： 90.0(a + b) * (c &#x2F; d) 运算结果为： 90.0a + (b * c) &#x2F; d 运算结果为： 50.0 and 拥有更高优先级: 12345678x = Truey = Falsez = Falseif x or y and z: print(&quot;yes&quot;)else: print(&quot;no&quot;) 以上实例先计算 y and z 并返回 False ，然后 x or False 返回 True，输出结果： yes","path":"2022/09/28/Python3-运算符/","date":"09-28","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"}]},{"title":"Python3 推导式","text":"Python 推导式Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。 Python 支持各种数据结构的推导式： 列表(list)推导式 字典(dict)推导式 集合(set)推导式 元组(tuple)推导式 列表推导式列表推导式格式为： [表达式 for 变量 in 列表][out_exp_res for out_exp in input_list]或者[表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition] out_exp_res：列表生成元素表达式，可以是有返回值的函数。 for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。 if condition：条件语句，可以过滤列表中不符合条件的值。 过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母： 1234&gt;&gt;&gt; names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;] &gt;&gt;&gt; new_names = [name.upper()for name in names if len(name)&gt;3] &gt;&gt;&gt; print(new_names) [&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;] 计算 30 以内可以被 3 整除的整数： 123&gt;&gt;&gt; multiples = [i for i in range(30) if i % 3 == 0]&gt;&gt;&gt; print(multiples)[0, 3, 6, 9, 12, 15, 18, 21, 24, 27] 字典推导式字典推导基本格式： { key_expr: value_expr for value in collection }或{ key_expr: value_expr for value in collection if condition } 使用字符串及其长度创建字典： 1234&gt;&gt;&gt; listdemo = [&#x27;Google&#x27;,&#x27;Runoob&#x27;,&#x27;Taobao&#x27;]&gt;&gt;&gt; newdict = &#123;key:len(key) for key in listdemo&#125;&gt;&gt;&gt; newdict&#123;&#x27;Google&#x27;: 6, &#x27;Runoob&#x27;: 6, &#x27;Taobao&#x27;: 6&#125; 提供三个数字，以三个数字为键，三个数字的平方为值来创建字典： 12345&gt;&gt;&gt; dic = &#123;x:x**2 for x in (2,4,6)&#125;&gt;&gt;&gt; dic&#123;2: 4, 4: 16, 6: 36&#125;&gt;&gt;&gt; type(dic)&lt;class &#x27;dict&#x27;&gt; 集合推导式集合推导式基本格式： { expression for item in Sequence }或{ expression for item in Sequence if conditional } 计算数字 1,2,3 的平方数： 123&gt;&gt;&gt; setnew = &#123;i**2 for i in (1,2,3)&#125; &gt;&gt;&gt; setnew &#123;1, 4, 9&#125; 判断不是 abc 的字母并输出： 12345&gt;&gt;&gt; a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125; &gt;&gt;&gt; a &#123;&#x27;d&#x27;, &#x27;r&#x27;&#125; &gt;&gt;&gt; type(a) &lt;class &#x27;set&#x27;&gt; 元组推导式（生成器表达式）元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。 元组推导式基本格式： (expression for item in Sequence )或(expression for item in Sequence if conditional ) 元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 []，另外元组推导式返回的结果是一个生成器对象。 例如，我们可以使用下面的代码生成一个包含数字 1~9 的元组： 123456&gt;&gt;&gt; a = (x for x in range(1,10)) &gt;&gt;&gt; a &lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt; # 返回的是生成器对象 &gt;&gt;&gt; tuple(a) # 使用 tuple() 函数，可以直接将生成器对象转换成元组 (1, 2, 3, 4, 5, 6, 7, 8, 9)","path":"2022/09/28/Python3-推导式/","date":"09-28","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"}]},{"title":"Python3 数据类型转换","text":"Python3 数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，一般情况下你只需要将数据类型作为函数名即可。 Python 数据类型转换可以分为两种： 隐式类型转换 - 自动完成 显式类型转换 - 需要使用类型函数来转换 隐式类型转换在隐式类型转换中，Python 会自动将一种数据类型转换为另一种数据类型，不需要我们去干预。 以下实例中，我们对两种不同类型的数据进行运算，较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。 12345678910num_int = 123num_flo = 1.23num_new = num_int + num_floprint(&quot;datatype of num_int:&quot;, type(num_int))print(&quot;datatype of num_flo:&quot;, type(num_flo))print(&quot;Value of num_new:&quot;, num_new)print(&quot;datatype of num_new:&quot;,type(num_new)) 以上实例输出结果为： datatype of num_int: &lt;class ‘int’&gt;datatype of num_flo: &lt;class ‘float’&gt;Value of num_new: 124.23datatype of num_new: &lt;class ‘float’&gt; 代码解析： 实例中我们对两个不同数据类型的变量 num_int 和 num_flo 进行相加运算，并存储在变量 num_new 中。 然后查看三个变量的数据类型。 在输出结果中，我们看到 num_int 是 整型（integer） ， num_flo 是 浮点型（float）。 同样，新的变量 num_new 是 浮点型（float），这是因为 Python 会将较小的数据类型转换为较大的数据类型，以避免数据丢失。 我们再看一个实例，整型数据与字符串类型的数据进行相加： 1234567num_int = 123num_str = &quot;456&quot;print(&quot;Data type of num_int:&quot;,type(num_int))print(&quot;Data type of num_str:&quot;,type(num_str))print(num_int + num_str) 以上实例输出结果为： 从输出中可以看出，整型和字符串类型运算结果会报错，输出 TypeError。 Python 在这种情况下无法使用隐式转换。 但是，Python 为这些类型的情况提供了一种解决方案，称为显式转换。 显式类型转换在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。 int() 强制转换为整型： x &#x3D; int(1) # x 输出结果为 1y &#x3D; int(2.8) # y 输出结果为 2z &#x3D; int(“3”) # z 输出结果为 3 float() 强制转换为浮点型： x &#x3D; float(1) # x 输出结果为 1.0y &#x3D; float(2.8) # y 输出结果为 2.8z &#x3D; float(“3”) # z 输出结果为 3.0w &#x3D; float(“4.2”) # w 输出结果为 4.2 str() 强制转换为字符串类型： x &#x3D; str(“s1”) # x 输出结果为 ‘s1’y &#x3D; str(2) # y 输出结果为 ‘2’z &#x3D; str(3.0) # z 输出结果为 ‘3.0’ 整型和字符串类型进行运算，就可以用强制类型转换来完成： 12345678910111213num_int = 123num_str = &quot;456&quot;print(&quot;num_int 数据类型为:&quot;,type(num_int))print(&quot;类型转换前,num_str数据类型为:&quot;,type(num_str))num_str = int(num_str)print(&quot;类型转换后,num_str 数据类型为:&quot;,type(num_str))num_sum = num_int + num_str print(&quot;num_int 与 num_str 相加结果为:&quot;,num_sum)print(&quot;sum 数据类型为:&quot;,type(num_sum)) 以上实例输出结果为： num_int 数据类型为: &lt;class ‘int’&gt;类型转换前,num_str数据类型为: &lt;class ‘str’&gt;类型转换后,num_str 数据类型为: &lt;class ‘int’&gt;num_int 与 num_str 相加结果为: 579sum 数据类型为: &lt;class ‘int’&gt; 以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。 函数 描述 int(x[,base]) 将x转换成为一个整数 float(x) 将x转换到一个浮点数 complex(real[,imag]) 创建一个复数 str(x) 将对象x转换为字符串 repr(x) 将对象x转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(s) 创建一个字典。d 必须是一个 (key, value)元组序列。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串","path":"2022/09/28/Python3-数据类型转换/","date":"09-28","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"}]},{"title":"Java爬虫之JSoup使用教程","text":"介绍JSoup是一个用于处理HTML的Java库，它提供了一个非常方便类似于使用DOM，CSS和jquery的方法的API来提取和操作数据。 主要类1. org.jsoup.Jsoup类Jsoup类是任何Jsoup程序的入口点，并将提供从各种来源加载和解析HTML文档的方法。 Jsoup类的一些重要方法如下： 方法 姓名 static Connection connect(String url) 创建并返回URL的连接。 static Document parse(File in, String charsetName) 将指定的字符集文件解析成文档。 static Document parse(String html) 将给定的html代码解析成文档。 static String clean(String bodyHtml, Whitelist whitelist) 从输入HTML返回安全的HTML，通过解析输入HTML并通过允许的标签和属性的白名单进行过滤。 2. org.jsoup.nodes.Document类该类表示通过Jsoup库加载HTML文档。可以使用此类执行适用于整个HTML文档的操作。 Element类的重要方法可以参见 - http://jsoup.org/apidocs/org/jsoup/nodes/Document.html 。 3. org.jsoup.nodes.Element类HTML元素是由标签名称，属性和子节点组成。 使用Element类，您可以提取数据，遍历节点和操作HTML。 Element类的重要方法可参见 - http://jsoup.org/apidocs/org/jsoup/nodes/Element.html 。 简单使用安装 使用maven导包，也可以使用jar 12345&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.15.3&lt;/version&gt; &lt;/dependency&gt; 加载文档1. URL加载文档从URL加载文档，使用Jsoup.connect()方法从URL加载HTML。 123456try &#123; Document document = Jsoup.connect(&quot;https://www.kwydy.cn&quot;).get(); System.out.println(document.title()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 2. 从文件加载文档使用Jsoup.parse()方法从文件加载HTML。 123456try &#123; Document document = Jsoup.parse( new File( &quot;D:/temp/index.html&quot; ) , &quot;utf-8&quot; ); System.out.println(document.title()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 3. 从String加载文档使用Jsoup.parse()方法从字符串加载HTML。 1234567try &#123; String html = &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;First parse&lt;/title&gt;&lt;/head&gt;&quot; + &quot;&lt;body&gt;&lt;p&gt;Parsed HTML into a doc.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;; Document document = Jsoup.parse(html); System.out.println(document.title()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 提取数据使用DOM方法导航文档元素提供了一系列类似DOM的方法来查找元素，并提取和操作它们的数据。DOM getter是上下文的：在父文档上调用，他们在文档下找到匹配的元素; 他们在一个子元素上调用了那个孩子下面的元素。通过这种方式，您可以了解所需的数据。 寻找元素 getElementById(String id) getElementsByTag(String tag) getElementsByClass(String className) getElementsByAttribute(String key) （及相关方法） 元素的兄弟姐妹：siblingElements()，firstElementSibling()，lastElementSibling()，nextElementSibling()，previousElementSibling() 图：parent()，children()，child(int index) 处理元素数据 attr(String key)获取和attr(String key, String value)设置属性 attributes() 获得所有属性 id()，className()和classNames() text()获取和text(String value)设置文本内容 html()获取和html(String value)设置内部HTML内容 outerHtml() 获取外部HTML值 data()获取数据内容（例如script和style标签） tag() 和 tagName() 操纵HTML和文本 append(String html)， prepend(String html) appendText(String text)， prependText(String text) appendElement(String tagName)， prependElement(String tagName) html(String value) 实战爬取图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Test &#123; static String WEB_URL = &quot;https://wall.alphacoders.com/by_category.php?id=3&amp;name=Anime+Wallpapers&amp;page=6&quot;; static int index = 0; static int page = 6; public static void main(String[] args) throws IOException &#123; get(WEB_URL); &#125; public static void get(String WEB_URL) throws IOException &#123; Connection connection = Jsoup.connect(WEB_URL).ignoreContentType(true).timeout(60000); Document document = connection.get(); List&lt;String&gt; collect = document.getElementsByClass(&quot;boxgrid&quot;).select(&quot;a&quot;).stream().map(e -&gt; e.attr(&quot;href&quot;)).collect(Collectors.toList()); collect.forEach(imgUrl -&gt; &#123; String URL = &quot;https://wall.alphacoders.com&quot; + imgUrl; Connection connection1 = Jsoup.connect(URL).ignoreContentType(true).timeout(60000); try &#123; Document document1 = connection1.get(); String src = document1.getElementsByClass(&quot;main-content&quot;).attr(&quot;src&quot;); downloadPicture(src, &quot;E:\\\\博客壁纸\\\\&quot; + src.substring(src.lastIndexOf(&quot;/&quot;) + 1)); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125;); &#125; public static void downloadPicture(String imageUrl, String path) throws IOException &#123; System.out.println(imageUrl); index++; System.out.println(index); URL url = null; try &#123; url = new URL(imageUrl); DataInputStream dataInputStream = new DataInputStream(url.openStream()); FileOutputStream fileOutputStream = new FileOutputStream(new File(path)); ByteArrayOutputStream output = new ByteArrayOutputStream(); byte[] buffer = new byte[4096]; int length; while ((length = dataInputStream.read(buffer)) &gt; 0) &#123; output.write(buffer, 0, length); &#125; fileOutputStream.write(output.toByteArray()); dataInputStream.close(); fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (index &gt;= 30) &#123; index = 0; page++; WEB_URL = &quot;https://wall.alphacoders.com/by_category.php?id=3&amp;name=Anime+Wallpapers&amp;page=&quot; + page; System.out.println(WEB_URL); get(WEB_URL); &#125; &#125; &#125; 运行截图","path":"2022/09/25/Java爬虫之JSoup使用教程/","date":"09-25","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://wanwan-doudou/github.io/tags/java/"}]},{"title":"Python3 基本数据类型","text":"Python3 基本数据类型Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。等号（&#x3D;）用来给变量赋值。等号（&#x3D;）运算符左边是一个变量名,等号（&#x3D;）运算符右边是存储在变量中的值。例如： 1234567counter = 100miles = 1000.0name = &quot;kwydy&quot;print(counter)print(miles)print(name) 执行以上程序会输出如下结果： 1001000.0kwydy 多个变量赋值Python允许你同时为多个变量赋值。例如： 1a = b = c = 1 以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。 您也可以为多个对象指定多个变量。例如： 1a, b, c = 1, 2, &quot;kwydy&quot; 以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “kwydy” 分配给变量 c。 标准数据类型Python3 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 Number (数字)Python3 支持 int、float、bool、complex（复数）在Python3里， 只有一种整数类型 int，表示长整型， 没有 python2中的Long。像大多数语言一样，数值类型的赋值和计算都是很直观的。内置的 type() 函数可以用来查询变量所指的对象类型。 123&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt; 此外还可以用 isinstance 来判断： 1234&gt;&gt;&gt; a = 111 &gt;&gt;&gt; isinstance(a, int) True &gt;&gt;&gt; isinstance 和 type 的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是父类的类型。 1234567891011121314&gt;&gt;&gt; class A:... pass... &gt;&gt;&gt; class B(A):... pass... &gt;&gt;&gt; isinstance(A(), A)True&gt;&gt;&gt; type(A()) == A True&gt;&gt;&gt; isinstance(B(), A)True&gt;&gt;&gt; type(B()) == AFalse 注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True=&#x3D;1、False=&#x3D;0 会返回 True，但可以通过 is 来判断类型。 1234567891011121314&gt;&gt;&gt; issubclass(bool, int) True&gt;&gt;&gt; True==1True&gt;&gt;&gt; False==0True&gt;&gt;&gt; True+12&gt;&gt;&gt; False+11&gt;&gt;&gt; 1 is TrueFalse&gt;&gt;&gt; 0 is FalseFalse 在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。 当你指定一个值时，Number 对象就会被创建 12var1 = 1var2 = 10 您也可以使用del语句删除一些对象引用。del语句的语法是： 1del var1[,var2[,var3[....,varN]]] 您可以通过使用del语句删除单个或多个对象。例如： 12del vardel var_a, var_b 数值运算1234567891011121314&gt;&gt;&gt; 5 + 4 # 加法 9 &gt;&gt;&gt; 4.3 - 2 # 减法 2.3 &gt;&gt;&gt; 3 * 7 # 乘法 21 &gt;&gt;&gt; 2 / 4 # 除法，得到一个浮点数 0.5 &gt;&gt;&gt; 2 // 4 # 除法，得到一个整数 0 &gt;&gt;&gt; 17 % 3 # 取余 2 &gt;&gt;&gt; 2 ** 5 # 乘方 32 注意： 1、Python可以同时为多个变量赋值，如a, b &#x3D; 1, 2。 2、一个变量可以通过赋值指向不同类型的对象。 3、数值的除法包含两个运算符：&#x2F; 返回一个浮点数，&#x2F;&#x2F; 返回一个整数。 4、在混合计算时，Python会把整型转换成为浮点数。 数值类型实例 Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型 String（字符串）Python中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \\ 转义特殊字符。字符串的截取的语法格式如下： 变量[头下标:尾下标] 索引值以 0 为开始值，-1 为从末尾的开始位置。 加号 + 是字符串的连接符， 星号 * 表示复制当前字符串，与之结合的数字为复制的次数。实例如下： 123456789str = &#x27;Runoob&#x27; print (str) # 输出字符串 print (str[0:-1]) # 输出第一个到倒数第二个的所有字符 print (str[0]) # 输出字符串第一个字符 print (str[2:5]) # 输出从第三个开始到第五个的字符 print (str[2:]) # 输出从第三个开始的后的所有字符 print (str * 2) # 输出字符串两次，也可以写成 print (2 * str) print (str + &quot;TEST&quot;) # 连接字符串 执行以上程序会输出如下结果： RunoobRunooRnoonoobRunoobRunoobRunoobTEST Python 使用反斜杠 \\ 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串： 123456&gt;&gt;&gt; print(&#x27;Ru\\noob&#x27;) Ru oob &gt;&gt;&gt; print(r&#x27;Ru\\noob&#x27;) Ru\\noob &gt;&gt;&gt; 另外，反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 “””…””” 或者 ‘’’…’’’ 跨越多行。 注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。 12345&gt;&gt;&gt; word = &#x27;Python&#x27; &gt;&gt;&gt; print(word[0], word[5]) P n &gt;&gt;&gt; print(word[-1], word[-6]) n P 与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] &#x3D; ‘m’会导致错误。 注意： 1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。 2、字符串可以用+运算符连接在一起，用*运算符重复。 3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。 4、Python中的字符串不能改变。 List（列表）List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 列表截取的语法格式如下： 变量[头下标:尾下标] 索引值以 0 为开始值，-1 为从末尾的开始位置。 加号 + 是列表连接运算符，星号 * 是重复操作。如下实例： 123456789list = [ &#x27;abcd&#x27;, 786 , 2.23, &#x27;runoob&#x27;, 70.2 ] tinylist = [123, &#x27;runoob&#x27;] print (list) # 输出完整列表 print (list[0]) # 输出列表第一个元素 print (list[1:3]) # 从第二个开始输出到第三个元素 print (list[2:]) # 输出从第三个元素开始的所有元素 print (tinylist * 2) # 输出两次列表 print (list + tinylist) # 连接列表 以上实例输出结果： [‘abcd’, 786, 2.23, ‘runoob’, 70.2]abcd[786, 2.23][2.23, ‘runoob’, 70.2][123, ‘runoob’, 123, ‘runoob’][‘abcd’, 786, 2.23, ‘runoob’, 70.2, 123, ‘runoob’] 与Python字符串不一样的是，列表中的元素是可以改变的： 12345678&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6] &gt;&gt;&gt; a[0] = 9 &gt;&gt;&gt; a[2:5] = [13, 14, 15] &gt;&gt;&gt; a [9, 2, 13, 14, 15, 6] &gt;&gt;&gt; a[2:5] = [] # 将对应的元素值设置为 [] &gt;&gt;&gt; a [9, 2, 6] 注意： 1、List写在方括号之间，元素用逗号隔开。 2、和字符串一样，list可以被索引和切片。 3、List可以使用+操作符进行拼接。 4、List中的元素是可以改变的。 Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串： 1234567891011121314151617181920212223def reverseWords(input): # 通过空格将字符串分隔符，把各个单词分隔为列表 inputWords = input.split(&quot; &quot;) # 翻转字符串 # 假设列表 list = [1,2,3,4], # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) # inputWords[-1::-1] 有三个参数 # 第一个参数 -1 表示最后一个元素 # 第二个参数为空，表示移动到列表末尾 # 第三个参数为步长，-1 表示逆向 inputWords=inputWords[-1::-1] # 重新组合字符串 output = &#x27; &#x27;.join(inputWords) return output if __name__ == &quot;__main__&quot;: input = &#x27;I like runoob&#x27; rw = reverseWords(input) print(rw) 输出结果为： runoob like I Tuple（元组）元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。 元组中的元素类型也可以不相同： 123456789tuple = ( &#x27;abcd&#x27;, 786 , 2.23, &#x27;runoob&#x27;, 70.2 ) tinytuple = (123, &#x27;runoob&#x27;) print (tuple) # 输出完整元组 print (tuple[0]) # 输出元组的第一个元素 print (tuple[1:3]) # 输出从第二个元素开始到第三个元素 print (tuple[2:]) # 输出从第三个元素开始的所有元素 print (tinytuple * 2) # 输出两次元组 print (tuple + tinytuple) # 连接元组 以上实例输出结果： (‘abcd’, 786, 2.23, ‘runoob’, 70.2)abcd(786, 2.23)(2.23, ‘runoob’, 70.2)(123, ‘runoob’, 123, ‘runoob’)(‘abcd’, 786, 2.23, ‘runoob’, 70.2, 123, ‘runoob’) 元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。 其实，可以把字符串看作一种特殊的元组。 12345678910&gt;&gt;&gt; tup = (1, 2, 3, 4, 5, 6) &gt;&gt;&gt; print(tup[0]) 1 &gt;&gt;&gt; print(tup[1:5]) (2, 3, 4, 5) &gt;&gt;&gt; tup[0] = 11 # 修改元组元素的操作是非法的 Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: &#x27;tuple&#x27; object does not support item assignment &gt;&gt;&gt; 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： tup1 &#x3D; () # 空元组tup2 &#x3D; (20,) # 一个元素，需要在元素后添加逗号 string、list 和 tuple 都属于 sequence（序列）。 注意： 1、与字符串一样，元组的元素不能修改。 2、元组也可以被索引和切片，方法一样。 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。 4、元组也可以使用+操作符进行拼接。 Set（集合）集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。 基本功能是进行成员关系测试和删除重复元素。 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 创建格式： parame &#x3D; {value01,value02,…}或者set(value) 1234567891011121314151617181920212223#!/usr/bin/python3 sites = &#123;&#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Facebook&#x27;, &#x27;Zhihu&#x27;, &#x27;Baidu&#x27;&#125; print(sites) # 输出集合，重复的元素被自动去掉 # 成员测试 if &#x27;Runoob&#x27; in sites : print(&#x27;Runoob 在集合中&#x27;) else : print(&#x27;Runoob 不在集合中&#x27;) # set可以进行集合运算 a = set(&#x27;abracadabra&#x27;) b = set(&#x27;alacazam&#x27;) print(a) print(a - b) # a 和 b 的差集 print(a | b) # a 和 b 的并集 print(a &amp; b) # a 和 b 的交集 print(a ^ b) # a 和 b 中不同时存在的元素 以上实例输出结果： {‘Zhihu’, ‘Baidu’, ‘Taobao’, ‘Runoob’, ‘Google’, ‘Facebook’}Runoob 在集合中{‘b’, ‘c’, ‘a’, ‘r’, ‘d’}{‘r’, ‘b’, ‘d’}{‘b’, ‘c’, ‘a’, ‘z’, ‘m’, ‘r’, ‘l’, ‘d’}{‘c’, ‘a’}{‘z’, ‘b’, ‘m’, ‘r’, ‘l’, ‘d’} Dictionary（字典）字典（dictionary）是Python中另一个非常有用的内置数据类型。 列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。 键(key)必须使用不可变类型。 在同一个字典中，键(key)必须是唯一的。 123456789101112dict = &#123;&#125; dict[&#x27;one&#x27;] = &quot;1 - 菜鸟教程&quot; dict[2] = &quot;2 - 菜鸟工具&quot; tinydict = &#123;&#x27;name&#x27;: &#x27;runoob&#x27;,&#x27;code&#x27;:1, &#x27;site&#x27;: &#x27;www.runoob.com&#x27;&#125; print (dict[&#x27;one&#x27;]) # 输出键为 &#x27;one&#x27; 的值 print (dict[2]) # 输出键为 2 的值 print (tinydict) # 输出完整的字典 print (tinydict.keys()) # 输出所有键 print (tinydict.values()) # 输出所有值 以上实例输出结果： 1 - 菜鸟教程2 - 菜鸟工具{‘name’: ‘runoob’, ‘code’: 1, ‘site’: ‘www.runoob.com&#39;}dict_keys([‘name’, ‘code’, ‘site’])dict_values([‘runoob’, 1, ‘www.runoob.com&#39;]) 构造函数 dict() 可以直接从键值对序列中构建字典如下： 123456&gt;&gt;&gt; dict([(&#x27;Runoob&#x27;, 1), (&#x27;Google&#x27;, 2), (&#x27;Taobao&#x27;, 3)]) &#123;&#x27;Runoob&#x27;: 1, &#x27;Google&#x27;: 2, &#x27;Taobao&#x27;: 3&#125; &gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125; &#123;2: 4, 4: 16, 6: 36&#125; &gt;&gt;&gt; dict(Runoob=1, Google=2, Taobao=3) &#123;&#x27;Runoob&#x27;: 1, &#x27;Google&#x27;: 2, &#x27;Taobao&#x27;: 3&#125; {x: x**2 for x in (2, 4, 6)} 该代码使用的是字典推导式，更多推导式内容可以参考：Python 推导式。 另外，字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。 注意： 1、字典是一种映射类型，它的元素是键值对。 2、字典的关键字必须为不可变类型，且不能重复。 3、创建空字典使用 **{ }**。 Python数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可 以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。","path":"2022/09/20/Python3-基本数据类型/","date":"09-20","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"}]},{"title":"Python3 基础语法","text":"标识符 第一个字符必须是字母表中字母或下划线 _ 。 标识符的其他的部分由字母、数字和下划线组成。 标识符对大小写敏感。 在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。 python保留字保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字： 1234import keywordkeyword.kwlist[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;] 注释Python中单行注释以 # 开头，实例如下： 123# 第一个注释print (&quot;Hello, Python!&quot;) # 第二个注释 执行以上代码，输出结果为： 多行注释可以用多个 # 号，还有 ‘’’ 和 “””： 1234567891011121314# 第一个注释# 第二个注释&#x27;&#x27;&#x27;第三注释第四注释&#x27;&#x27;&#x27;&quot;&quot;&quot;第五注释第六注释&quot;&quot;&quot;print (&quot;Hello, Python!&quot;) 执行以上代码，输出结果为： 行与缩进python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下： 1234if True: print (&quot;True&quot;)else: print (&quot;False&quot;) 以下代码最后一行语句缩进数的空格数不一致，会导致运行错误： 123456if True: print (&quot;Answer&quot;) print (&quot;True&quot;)else: print (&quot;Answer&quot;) print (&quot;False&quot;) # 缩进不一致，会导致运行错误 以上程序由于缩进不一致，执行后会出现类似以下错误： 多行语句Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \\ 来实现多行语句，例如： 123total = item_one + \\ item_two + \\ item_three 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \\，例如： 1total = [&#x27;item_ont&#x27;,&#x27;item_tow&#x27;,&#x27;item_three&#x27;,&#x27;item_four&#x27;,&#x27;item_five&#x27;] 数字(Number)类型python中数字有四种类型：整数、布尔型、浮点数和复数。 int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 bool (布尔), 如 True。 float (浮点数), 如 1.23、3E-2 complex (复数), 如 1 + 2j、 1.1 + 2.2j 字符串(String) Python 中单引号 ‘ 和双引号 “ 使用完全相同。 使用三引号(‘’’ 或 “””)可以指定一个多行字符串。 转义符 \\。 反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \\n” 则 \\n 会显示，并不是换行。 按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python 中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标:步长] 123word = &#x27;字符串&#x27;sentence = &quot;这是一个句子&quot;paragraph = &quot;&quot;&quot;我是第一行,我是第二行&quot;&quot;&quot; 123456789101112131415str=&#x27;123456789&#x27;print(str) # 输出字符串print(str[0:-1]) # 输出第一个到倒数第二个的所有字符print(str[0]) # 输出字符串第一个字符print(str[2:5]) # 输出从第三个开始到第五个的字符print(str[2:]) # 输出从第三个开始后的所有字符print(str[1:5:2]) # 输出从第二个开始到第五个且每隔一个的字符（步长为2）print(str * 2) # 输出字符串两次print(str + &#x27;你好&#x27;) # 连接字符串print(&#x27;------------------------------&#x27;)print(&#x27;hello\\nrunoob&#x27;) # 使用反斜杠(\\)+n转义特殊字符print(r&#x27;hello\\nrunoob&#x27;) # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 这里的 r 指 raw，即 raw string，会自动将反斜杠转义，例如： 以上实例输出结果： 空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 等待用户输入执行下面的程序在按回车键后就会等待用户输入： 1input(&quot;\\n\\n按下 enter 键后退出。&quot;) 以上代码中 ，\\n\\n 在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。 同一行显示多条语句Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割，以下是一个简单的实例： 1import sys; x = &#x27;runoob&#x27;; sys.stdout.write(x + &#x27;\\n&#x27;) 使用脚本执行以上代码，输出结果为： 使用交互式命令行执行，输出结果为： 此处的 7 表示字符数，runoob 有 6 个字符，\\n 表示一个字符，加起来 7 个字符。 123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.stdout.write(&quot; hi &quot;) # hi 前后各有 1 个空格 hi 4 多个语句构成代码组缩进相同的一组语句构成一个代码块，我们称之代码组。 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。 如下实例： 123456if expression : suiteelif expression : suite else : suite print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end&#x3D;””： 123456789101112x=&quot;a&quot;y=&quot;b&quot;# 换行输出print( x )print( y )print(&#x27;---------&#x27;)# 不换行输出print( x, end=&quot; &quot; )print( y, end=&quot; &quot; )print() 以上实例执行结果为： import 与 from…import 在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 导入 sys 模块1234567## 导入 sys 模块import sysprint(&#x27;================Python import mode==========================&#x27;)print (&#x27;命令行参数为:&#x27;)for i in sys.argv: print (i)print (&#x27;\\n python 路径为&#x27;,sys.path) 导入 sys 模块的 argv,path 成员123from sys import argv,path # 导入特定的成员print(&#x27;================python from import===================================&#x27;)print(&#x27;path:&#x27;,path) # 因为已经导入path成员，所以此处引用时不需要加sys.path","path":"2022/09/19/Python3-基础语法/","date":"09-19","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"}]},{"title":"Python安装","text":"1. 前往python官网下载python3官网链接：https://www.python.org/downloads/windows/ 2. 进行python3安装 在选择路径安装时，记得把下方的“Add Python 3.10 toPATH”勾选上，这样就不用手动配置环境变量了，后续不用再添加环境变量。 这里我们装到D盘 安装成功后，cmd控制台输入python，查看是否成功。出现下面证明安装成功。 3. 最后我们安装 VS Code Python 扩展","path":"2022/09/18/Python3安装/","date":"09-18","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"}]},{"title":"快速创建一个mybatis-plus项目","text":"创建项目 导入依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- SpringBoot环境依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.kwydy&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;mybatis-plus&lt;/name&gt; &lt;description&gt;mybatis-plus&lt;/description&gt; &lt;!-- JDK依赖 --&gt; &lt;properties&gt; &lt;java.version&gt;18&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- SpringMVC依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Test依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MyBatis-Plus依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Lombok依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 配置yml 12345678910spring: datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=UTC username: root password: root server: port: 8081 构建项目 编写实体类 User.java 123456789@Component //（把普通pojo实例化到spring容器中，相当于配置文件中的 &lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;） @Data public class User &#123; private Integer id; private String name; private Integer age; private String email; &#125; 编写 mapper 中的 UserMapper接口 123@Mapper public interface UserMapper extends BaseMapper&lt;User&gt; &#123; &#125; 编写service 中的 IUserService接口 12public interface IUserService extends IService&lt;User&gt; &#123; &#125; 编写impl 中 的 UserServiceImpl实现类 1234@Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements IUserService &#123; &#125; 编写controller 中 的 UserController 12345678910111213@RestController @RequestMapping(&quot;/user&quot;) public class UserController &#123; @Resource private IUserService userService; @GetMapping public List&lt;User&gt; getUser() &#123; return userService.list(); &#125; &#125; 搭建好之后就可以运行项目了浏览器服务localhost:8081&#x2F;user 这是运行截图","path":"2022/09/14/快速创建一个mybatis-plus项目/","date":"09-14","excerpt":"","tags":[{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://wanwan-doudou/github.io/tags/mybatis-plus/"}]},{"title":"石蒜模拟器-为你的博客或网站加上🐟吧","text":"项目地址首先需要引入模块，可以使用 CDN 直接引入或者通过 NPM 包的形式安装： 12345678910111213&lt;!-- https://cdn.jsdelivr.net/npm/sakana-widget@2.2.2/lib/sakana.min.js --&gt;&lt;!-- https://cdnjs.cloudflare.com/ajax/libs/sakana-widget/2.2.2/sakana.min.js --&gt;&lt;div id=&quot;sakana-widget&quot; style=&quot;position:fixed ;bottom: 10px; right: 10px;&quot;&gt;&lt;/div&gt;&lt;script&gt; function initSakanaWidget() &#123; new SakanaWidget().mount(&#x27;#sakana-widget&#x27;); &#125;&lt;/script&gt;&lt;script async onload=&quot;initSakanaWidget()&quot; src=&quot;https://cdn.jsdelivr.net/npm/sakana-widget@2.2.2/lib/sakana.min.js&quot;&gt;&lt;/script&gt; 123// npm install --save sakana-widgetimport SakanaWidget from &#x27;sakana-widget&#x27;;new SakanaWidget().mount(&#x27;#sakana-widget&#x27;); 效果图","path":"2022/09/01/石蒜模拟器-为你的博客或网站加上鱼吧/","date":"09-01","excerpt":"","tags":[{"name":"博客美化","slug":"博客美化","permalink":"https://wanwan-doudou/github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"}]},{"title":"让hexo在后台运行","text":"安装pm21npm install -g pm2 写一个运行脚本，在博客根目录下面创建一个hexo_run.js 12345678910//runconst &#123; exec &#125; = require(&#x27;child_process&#x27;)exec(&#x27;hexo server&#x27;,(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log(&#x27;exec error: $&#123;error&#125;&#x27;) return &#125; console.log(&#x27;stdout: $&#123;stdout&#125;&#x27;); console.log(&#x27;stderr: $&#123;stderr&#125;&#x27;);&#125;) 运行命令 1pm2 start hexo_run.js","path":"2022/09/01/让hexo在后台运行/","date":"09-01","excerpt":"","tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://wanwan-doudou/github.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"linux环境下升级node版本","text":"1. 清除缓存信息1sudo npm cache clean -f 2. 下载node安装包1sudo npm install -g n 3. 升级node到稳定版本1sudo n stable 4. 重启服务器5. 查看当前node版本1node -v","path":"2022/09/01/linux环境下升级node版本/","date":"09-01","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://wanwan-doudou/github.io/tags/linux/"}]},{"title":"linux查看占用端口的进程并杀死该进程","text":"lsoflsof(list open files)是一个列出当前系统打开文件的工具。 lsof 查看端口占用语法格式： 1lsof -i:端口号 查看服务器 8000 端口的占用情况： kill在查到端口占用的进程后，如果你要杀掉对应的进程可以使用 kill 命令： 1kill -9 PID 如上实例，我们看到 80 端口对应的 PID 为 1646，使用以下命令杀死进程： 1kill -9 1646","path":"2022/09/01/linux查看占用端口的进程并杀死该进程/","date":"09-01","excerpt":"","tags":[{"name":"linux","slug":"linux","permalink":"https://wanwan-doudou/github.io/tags/linux/"}]},{"title":"线程间通信","text":"线程间通信的几种实现方式题目：有多个个线程分别对int number操作，一共操作十次，当number等于0时number加一，当number等于1时number减一。 方式一：使用Object类的wait() 和 notifyAll() 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Share &#123; /** * 初始值 */ private int number = 0; /** * +1的方法 */ public synchronized void incr() throws InterruptedException &#123; // 第二部 判断 干活 通知 // 判断number值是否是0，如果不是0，等待 if (number != 0) &#123; this.wait(); &#125; // 弱国number值是0，就+1操作 number++; System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + number); // 通知其他线程 this.notifyAll(); &#125; /** * 减一的方法 */ public synchronized void decr() throws InterruptedException &#123; // 判断 if (number != 1) &#123; this.wait(); &#125; // 干活 number--; System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + number); this.notifyAll(); &#125; &#125; /** * @author myAnswer &lt;2273024587@qq.com&gt; * @since 2022/1/30 20:12 */ public class ThreadDemo1 &#123; public static void main(String[] args) &#123; Share share = new Share(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; share.incr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;AA&quot;).start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; share.decr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;BB&quot;).start(); &#125; &#125; 输出： 虚假唤醒问题这里我们创建4个线程发别执行加减的方法 1234567891011121314151617181920212223242526272829303132333435363738394041public class ThreadDemo1 &#123; public static void main(String[] args) &#123; Share share = new Share(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; share.incr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;AA&quot;).start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; share.decr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;BB&quot;).start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; share.incr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;CC&quot;).start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; share.decr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;DD&quot;).start(); &#125; &#125; 可以看到结果和预期不一致 解决方法：使用while判断，线程被唤醒时还要经过判断才往下走 123456789101112public synchronized void incr() throws InterruptedException &#123; // 第二部 判断 干活 通知 // 判断number值是否是0，如果不是0，等待 while (number != 0) &#123; this.wait(); &#125; // 如果number值是0，就+1操作 number++; System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + number); // 通知其他线程 this.notifyAll(); &#125; 方式二：使用 ReentrantLock123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Share &#123; private int number = 0; /** * 创建Lock */ private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); /** * +1 */ public void incr() throws InterruptedException &#123; // 上锁 lock.lock(); try &#123; // 判断 while (number != 0) &#123; condition.await(); &#125; // 干活 number++; System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + number); // 通知 condition.signalAll(); &#125; finally &#123; // 解锁 lock.unlock(); &#125; &#125; /** * 1- */ public void decr() throws InterruptedException &#123; // 上锁 lock.lock(); try &#123; // 判断 while (number != 1) &#123; condition.await(); &#125; // 干活 number--; System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + number); // 通知 condition.signalAll(); &#125; finally &#123; // 解锁 lock.unlock(); &#125; &#125; &#125; /** * @author myAnswer &lt;2273024587@qq.com&gt; * @since 2022/1/30 20:55 */ public class ThreadDemo2 &#123; public static void main(String[] args) &#123; Share share = new Share(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; share.incr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;AA&quot;).start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; share.decr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;BB&quot;).start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; share.incr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;CC&quot;).start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; share.decr(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;DD&quot;).start(); &#125; &#125; 运行结果为： 线程间定制化通信synchronized实现线程间通信的案例如果有多个线程那么就无法指定线程执行的顺序，我们可以使用Lock锁的Condition 实现线程定制化通信 实例：A线程打印2次A，B线程打印3次B，C线程打印5次C,按照此顺序循环10轮 思路：创建三个线程给每个线程设置一个标志位 线程A判断flag&#x3D;0，打印2次，修改flag&#x3D;1,通知线程B 线程B判断flag&#x3D;1，打印3次，修改flag&#x3D;2,通知线程C 线程C判断flag&#x3D;2，打印5次，修改flag&#x3D;0,通知线程A 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/** * 第一步 创建资源类 */ class ShareResource &#123; /** * 定义标志位 * 1 AA * 2 BB * 3 CC */ private int flag = 1; /** * 创建Lock锁 */ private Lock lock = new ReentrantLock(); /** * 创建三个condition */ private Condition c1 = lock.newCondition(); private Condition c2 = lock.newCondition(); private Condition c3 = lock.newCondition(); /** * @param loop 轮数 * @throws InterruptedException */ public void print5(int loop) throws InterruptedException &#123; // 上锁 lock.lock(); try &#123; // 判断 while (flag != 1) &#123; // 等待 c1.await(); &#125; // 干活 for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + i + &quot; :轮数&quot; + loop); &#125; // 通知 // 修改标志位2 flag = 2; // 通知BB线程 c2.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; /** * @param loop 轮数 * @throws InterruptedException */ public void print10(int loop) throws InterruptedException &#123; // 上锁 lock.lock(); try &#123; // 判断 while (flag != 2) &#123; // 等待 c2.await(); &#125; // 干活 for (int i = 1; i &lt;= 10; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + i + &quot; :轮数&quot; + loop); &#125; // 通知 // 修改标志位2 flag = 3; // 通知BB线程 c3.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; /** * @param loop 轮数 * @throws InterruptedException */ public void print15(int loop) throws InterruptedException &#123; // 上锁 lock.lock(); try &#123; // 判断 while (flag != 3) &#123; // 等待 c3.await(); &#125; // 干活 for (int i = 1; i &lt;= 15; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + i + &quot; :轮数&quot; + loop); &#125; // 通知 // 修改标志位2 flag = 1; // 通知BB线程 c1.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; /** * @author myAnswer &lt;2273024587@qq.com&gt; * @since 2022/1/30 21:50 */ public class ThreadDemo3 &#123; public static void main(String[] args) &#123; ShareResource shareResource = new ShareResource(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; shareResource.print5(i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;AA&quot;).start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; try &#123; shareResource.print10(i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;BB&quot;).start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 15; i++) &#123; try &#123; shareResource.print15(i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;CC&quot;).start(); &#125; &#125; 输出结果为：","path":"2022/01/30/线程间通信/","date":"01-30","excerpt":"","tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://wanwan-doudou/github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Lock接口","text":"2 Lock 接口2.1 复习Synchronized2.1.1 Synchronized关键字回顾 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象; 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作 用的对象是调用这个方法的对象; 虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized 关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象; 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 2.1.2售票操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Ticket &#123; /** * 票数 */ private int number = 30; /** * 操作方法：卖票 */ public synchronized void sale() &#123; // 判断：是否有票 if (number &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; : 卖出： &quot; + number-- + &quot;剩下：&quot; + number); &#125; &#125; &#125; /** * @author myAnswer &lt;2273024587@qq.com&gt; */ public class SaleTicket &#123; /** * 第二步 创建多个线程，调用资源类的操作方法 */ public static void main(String[] args) &#123; // 创建Ticket对象 Ticket ticket = new Ticket(); // 创建三个线程 new Thread(() -&gt; &#123; // 调用卖票方法 for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125;, &quot;AA&quot;).start(); new Thread(() -&gt; &#123; // 调用卖票方法 for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125;, &quot;BB&quot;).start(); new Thread(() -&gt; &#123; // 调用卖票方法 for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125;, &quot;CC&quot;).start(); &#125; &#125; 2.2 什么是Lock接口Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。Lock提供了比 synchronized更多的功能。 Lock 与的Synchronized区别:I Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问; Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用﹔而Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。 2.3 使用Lock实现卖票例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 第一步 创建资源类，定义属性和操作方法 * * @author myAnswer &lt;2273024587@qq.com&gt; * @since 2022/1/29 21:04 */ class LockTicket &#123; /** * 创建可重入锁 */ private final ReentrantLock lock = new ReentrantLock(); /** * 票数 */ private int number = 30; /** * 操作方法：卖票 */ public void sale() &#123; // 上锁 lock.lock(); try &#123; // 判断：是否有票 if (number &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; : 卖出： &quot; + number-- + &quot;剩下：&quot; + number); &#125; &#125; finally &#123; //解锁 lock.unlock(); &#125; &#125; &#125; /** * @author myAnswer &lt;2273024587@qq.com&gt; */ public class LockSaleTicket &#123; /** * 创建三个线程 */ public static void main(String[] args) &#123; LockTicket ticket = new LockTicket(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125;, &quot;AA&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125;, &quot;BB&quot;).start(); new Thread(() -&gt; &#123; for (int i = 0; i &lt; 40; i++) &#123; ticket.sale(); &#125; &#125;, &quot;CC&quot;).start(); &#125; &#125; 2.4 小结Lock和synchronized有以下几点不同: Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现; synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生;而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁;· Lock 可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized 时，等待的线程会一直等待下去，不能够响应中断; 通过Lock 可以知道有没有成功获取锁，而synchronized却无法办到。 Lock 可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock 的性能要远远优于synchronized。","path":"2022/01/29/Lock接口/","date":"01-29","excerpt":"","tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://wanwan-doudou/github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"JUC概述","text":"1 什么是JUC1.1 JUC简介在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK1.5开始出现的。 1.2 进程和线程进程(Process )是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。, 线程( thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 总结来说:进程∶指在系统中正在运行的一个应用程序﹔程序一旦运行就是进程﹔进程——资源分配的最小单位。线程︰系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。 1.3 线程的状态1.3.1 线程状态枚举Thread.State 1234567891011public enum State &#123; /** * Thread state for a thread which has not yet started. */ NEW,(新建&#125; RUNNABLE,(准备就绪) BLOCKED,(阻塞) WAITING,(不见不散) TIMED_WAITING,(过时不候) TERMINATED;(终结) &#125; 1.3.2 wait &#x2F; sleep 的区别( 1 ) sleep是Thread 的静态方法，wait是 Object的方法，任何对象实例都能调用。 ( 2 ) sleep不会释放锁，它也不需要占用锁。wait 会释放锁，但调用它的前提是当前线程占有锁(即代码要在synchronized 中)。 ( 3 )它们都可以被interrupted方法中断。 1.4 并发与并行1.4.1 串行模式串行表示所有任务都——按先后顺序进行。串行意味着必须先装完一车柴才能运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步骤，才能进行下一个步骤。 串行是一次只能取得一个任务，并执行这个任务。 1.4.2 并行模式并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。并行的效率从代码层次上强依赖于多进程&#x2F;多线程代码，从硬件角度上则依赖于多核CPU。 1.4.3 并发并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行。但这不是重点，在描述并发的时候也不会去扣这种字眼是否精确，&#x3D;&#x3D;并发的重点在于它是一种现象&#x3D;&#x3D;，&#x3D;&#x3D;并发描述的是多进程同时运行的现象&#x3D;&#x3D;。但实际上，对于单核心CPU来说，同一时刻只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占CPU的，而是执行一会停一会。 要解决大并发问题，通常是将大任务分解成多个小任务，由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象︰ 可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用队列或类似的数据结构来存放各个小任务的成果 可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或异步的方式，比如只有准备好产生了事件通知才执行某个任务。 可以多进程&#x2F;多线程的方式并行执行这些小任务。也可以单进程&#x2F;单线程执行这些小任务，这时很可能要配合多路复用才能达到较高的效率 1.4.4 小结（重点）并发：同一时刻多个线程在访问同一个资源，多个线程对一个点 ​ 例子∶春运抢票电商秒杀.…. 并行: 多项工作一起执行，之后再汇总: ​ 例子︰泡方便面，电水壶烧水，一边撕调料倒入桶中 1.5 管程 Monitor（监视器）保证同一时间，只有一个线程 1.6 用户线程和守护线程用户线程：自定义线程 主线程结束了，用户线程还在运行，jvm存活 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Thread aa = new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;::&quot; + Thread.currentThread().isDaemon()); while (true) &#123; &#125; &#125;, &quot;aa&quot;); aa.start(); System.out.println(Thread.currentThread().getName()+&quot;over&quot;); &#125; &#125; 123// 输出结果 main over aa::false 守护线程：比如垃圾回收 没有用户线程了，都是守护线程，jvm结束 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Thread aa = new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;::&quot; + Thread.currentThread().isDaemon()); while (true) &#123; &#125; &#125;, &quot;aa&quot;); // 设置守护线程 aa.setDaemon(true); aa.start(); System.out.println(Thread.currentThread().getName()+&quot;over&quot;); &#125; &#125; 123// 输出结果 main over aa::true 主线程退出后，守护线程依然在运行！由此得到只要任何非守护线程还在运行，守护线程就不会终止","path":"2022/01/29/JUC概述/","date":"01-29","excerpt":"","tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://wanwan-doudou/github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"Windows环境下redis配置文件修改没生效问题","text":"当我们安装了redis服务后，发现在其配置文件redis.windows.conf（或redis.conf）设置了密码：requirepass 123456 但是打开redis-cli.exe后输入命令config get requirepass发现： 这说明配置文件中密码设置后没有生效。原因：问题在于我们启动redis服务时是直接在其安装目录中双击redis-server.exe启动的，这样启动的结果是，配置文件不会指定，此时redis并不会自动使用安装目录下的redis.windows.conf（或redis.conf）文件 红线框住的的提示说的很明确“ Warning: no config file specified”没有指定配置文件 解决方法： 在redis安装目录下新建文件startup.bat后，右击“编辑”，或者先用记事本建立该文件，再把扩展名改一下，文件里面写上：redis-server.exe redis.windows.conf。保存，以后再运行就直接运行这个文件，不要再直接运行redis-server.exe了，就可以了。","path":"2022/01/27/Windows环境下redis配置文件修改没生效问题/","date":"01-27","excerpt":"","tags":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://wanwan-doudou/github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}]},{"title":"uniapp键盘弹出，页面内容被顶上去，解决办法","text":"修改pages.json文件中，需要弹出键盘的页面 123&quot;style&quot;: &#123; &quot;softinputMode&quot;: &quot;adjustResize&quot;, &#125; 12345678910&#123; &quot;path&quot;: &quot;pages/topics/detail/detail&quot;, &quot;style&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;&quot;, &quot;titleNView&quot;: false, &quot;navigationStyle&quot;: &quot;custom&quot;, &quot;softinputMode&quot;: &quot;adjustResize&quot;, &quot;enablePullDownRefresh&quot;: true &#125; &#125;,","path":"2022/01/26/uniapp键盘弹出，页面内容被顶上去，解决办法/","date":"01-26","excerpt":"","tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://wanwan-doudou/github.io/tags/uni-app/"}]},{"title":"uni-app分享微信群聊功能","text":"使用uni-app实现分享给微信群或者发布到朋友圈功能 uni.share(OBJECT)uni-app的App引擎已经封装了微信、QQ、微博的分享SDK，开发者可以直接调用相关功能。 可以分享到微信、QQ、微博，每个社交平台被称为分享服务提供商，即provider。 可以分享文字、图片、图文横条、音乐、视频等多种形式。同时注意，分享为小程序也使用本API。即在App里可以通过本API把一个内容以小程序（通常为内容页）方式直接分享给微信好友。 实例： 12345678910111213141516171819202122share() &#123; console.log(&#x27;share called&#x27;); let url = &#x27;https://www.kuangstudy.com/bbs/&#x27; + this.topicId; let cont = this.topic.topicContent.substring(0,30); console.log(&quot;cont&quot;,cont); console.log(&#x27;url&#x27;); uni.share(&#123; provider: &#x27;weixin&#x27;, scene: &#x27;WXSceneSession&#x27;, type: 0, href: url, summary: cont, title: this.topic.topicTitle, imageUrl: &#x27;https://www.kuangstudy.com/assert/images/avatar/1.jpg&#x27;, success: res =&gt; &#123; console.log(&#x27;success:&#x27; + JSON.stringify(res)); &#125;, fail: err =&gt; &#123; console.log(&#x27;fail:&#x27; + JSON.stringify(err)); &#125; &#125;); &#125;, 效果图：","path":"2022/01/25/uni-app分享微信群聊功能/","date":"01-25","excerpt":"","tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://wanwan-doudou/github.io/tags/uni-app/"}]},{"title":"sa-Token入门","text":"1、创建项目在IDE中新建一个SpringBoot项目 2、添加依赖在 pom.xml 中添加依赖： 123456&lt;!-- Sa-Token 权限认证, 在线文档：http://sa-token.dev33.cn/ --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.dev33&lt;/groupId&gt; &lt;artifactId&gt;sa-token-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.28.0&lt;/version&gt; &lt;/dependency&gt; 3、设置配置文件你可以零配置启动项目 ，但同时你也可以在application.yml中增加如下配置，定制性使用框架： 1234567891011121314151617181920server: # 端口 port: 8081 # Sa-Token配置 sa-token: # token名称 (同时也是cookie名称) token-name: satoken # token有效期，单位s 默认30天, -1代表永不过期 timeout: 2592000 # token临时有效期 (指定时间内无操作就视为token过期) 单位: 秒 activity-timeout: -1 # 是否允许同一账号并发登录 (为true时允许一起登录, 为false时新登录挤掉旧登录) is-concurrent: true # 在多人登录同一账号时，是否共用一个token (为true时所有登录共用一个token, 为false时每次登录新建一个token) is-share: false # token风格 token-style: uuid # 是否输出操作日志 is-log: false 4、创建启动类在项目中新建包 com.pj ，在此包内新建主类 SaTokenDemoApplication.java，输入以下代码： 1234567@SpringBootApplication public class SaTokenDemoApplication &#123; public static void main(String[] args) throws JsonProcessingException &#123; SpringApplication.run(SaTokenDemoApplication.class, args); System.out.println(&quot;启动成功：Sa-Token配置如下：&quot; + SaManager.getConfig()); &#125; &#125; 5、创建测试Controller12345678910111213141516171819202122@RestController @RequestMapping(&quot;/user/&quot;) public class UserController &#123; // 测试登录，浏览器访问： http://localhost:8081/user/doLogin?username=zhang&amp;password=123456 @RequestMapping(&quot;doLogin&quot;) public String doLogin(String username, String password) &#123; // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 if(&quot;zhang&quot;.equals(username) &amp;&amp; &quot;123456&quot;.equals(password)) &#123; StpUtil.login(10001); return &quot;登录成功&quot;; &#125; return &quot;登录失败&quot;; &#125; // 查询登录状态，浏览器访问： http://localhost:8081/user/isLogin @RequestMapping(&quot;isLogin&quot;) public String isLogin() &#123; return &quot;当前会话是否登录：&quot; + StpUtil.isLogin(); &#125; &#125; 6、运行启动代码，从浏览器依次访问上述测试接口：","path":"2022/01/23/sa-Token入门/","date":"01-23","excerpt":"","tags":[{"name":"sa-Token","slug":"sa-Token","permalink":"https://wanwan-doudou/github.io/tags/sa-Token/"}]},{"title":"es6解构赋值","text":"数组的解构赋值基本用法ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123let a = 1; let b = 2; let c = 3; ES6 允许写成下面这样。 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]]; foo // 1 bar // 2 baz // 3 let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]; third // &quot;baz&quot; let [x, , y] = [1, 2, 3]; x // 1 y // 3 let [head, ...tail] = [1, 2, 3, 4]; head // 1 tail // [2, 3, 4] let [x, y, ...z] = [&#x27;a&#x27;]; x // &quot;a&quot; y // undefined z // [] 如果解构不成功，变量的值就等于undefined。 12let [foo] = []; let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3]; x // 1 y // 2 let [a, [b], d] = [1, [2, 3], 4]; a // 1 b // 2 d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1234567// 报错 let [foo] = 1; let [foo] = false; let [foo] = NaN; let [foo] = undefined; let [foo] = null; let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。 对象解构赋值12345678910111213let msg = &#123;user:&#123;avatar:&#x27;头像&#x27;&#125;&#125; let obj = msg.user console.log(obj) console.log(msg.user) &#123;avatar: &#x27;头像&#x27;&#125; &#123;avatar: &#x27;头像&#x27;&#125; let msg = &#123;user:&#123;avatar:&#x27;头像&#x27;&#125;&#125; let obj = &#123; avatar: msg.user.avatar &#125; console.log(obj) console.log(msg.user) &#123;avatar: &#x27;头像&#x27;&#125; &#123;avatar: &#x27;头像&#x27;&#125;","path":"2022/01/22/es6解构赋值/","date":"01-22","excerpt":"","tags":[{"name":"es6","slug":"es6","permalink":"https://wanwan-doudou/github.io/tags/es6/"}]},{"title":"vue 数据绑定注意事项","text":"今天在项目中遇到了一个问题 我在data中定义了一个空 groupDetail: { }对象 123data() &#123; groupDetail: &#123;&#125;, &#125; 在回调函数中给这个groupDetail赋值，结构是这样的 123456groupDetail: &#123; data: &#123; name : &#x27;kwydy&#x27;, age : &#x27;19&#x27; &#125; &#125;, 在视图容器使用的时候我直接通过data.name去取，结果报错了 1&#123;&#123; groupDetail.data.name &#125;&#125; 把data里的groupDetail改成这样就可以了 1groupDetail: &#123; data: &#123;&#125; &#125;,","path":"2022/01/21/vue-数据绑定注意事项/","date":"01-21","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"https://wanwan-doudou/github.io/tags/vue/"}]},{"title":"mybatis-plus 根据条件动态修改条件构造器参数","text":"mybatis-plus 2022-01-21 我们有一个这样的需求： 群主能移除除了自己以外的所有群成员， 管理员能移除除群主和其他管理员的所有成员。 这里我们可以这样实现： 123// 将共有的查询方法抽取成一个wrapper LambdaQueryWrapper&lt;GroupLink&gt; wrapper = Wrappers.&lt;GroupLink&gt;lambdaQuery().eq(GroupLink::getGroupId, groupDTO.getId()) .in(GroupLink::getUserId, groupDTO.getGroupUserIds()); 这是枚举： 1234567891011121314@Getter @AllArgsConstructor public enum GroupRoleTypeEnum &#123; /** * Cheating the compiler and the god. */ NORMAL(&quot;普通用户&quot;), ADMIN(&quot;管理员&quot;), CREATOR(&quot;创建者&quot;); private final String desc; &#125; 1234567891011121314@Getter @AllArgsConstructor public enum GroupRoleTypeEnum &#123; /** * Cheating the compiler and the god. */ NORMAL(&quot;普通用户&quot;), ADMIN(&quot;管理员&quot;), CREATOR(&quot;创建者&quot;); private final String desc; &#125;","path":"2022/01/21/mybatis-plus-根据条件动态修改条件构造器参数/","date":"01-21","excerpt":"","tags":[{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://wanwan-doudou/github.io/tags/mybatis-plus/"}]},{"title":"三行代码让link转成VO","text":"123List&lt;GroupLinkVO&gt; linkUserList = groupLinks.parallelStream().map(l -&gt; BeanUtils.copyProperties(l, GroupLinkVO::new)) .peek(link -&gt; Opt.ofNullable(link.getUserId()).map(userMapByIds::get).peek(link::setUser)) .filter(link -&gt; Objects.nonNull(link.getUser())).collect(Collectors.toList());","path":"2022/01/19/三行代码让link转成VO/","date":"01-19","excerpt":"","tags":[{"name":"每日一个小技巧","slug":"每日一个小技巧","permalink":"https://wanwan-doudou/github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"实现微信群聊头像效果","text":"参考群聊头像（自用） - DCloud 插件市场 我们要实现这种效果 首先用使用HBuilderX导入插件 接着在uni_modules包下面会得到一这个这样的文件，我们要用到的是这个js文件 导入js 1import createAvatar from &#x27;@/uni_modules/ch-avatar/js_sdk/index.js&#x27;; 准备好你需要操作的图片 12345let imgs = [ &#x27;https://img0.baidu.com/it/u=3101694723,748884042&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, &#x27;https://img2.baidu.com/it/u=3566088443,3713209594&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, &#x27;https://img1.baidu.com/it/u=1361135963,570304265&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, &#x27;https://img1.baidu.com/it/u=2496571732,442429806&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, //这个链接是错的，为了体现获取图片错误时会获取本地默认图片 &#x27;https://img2.baidu.com/it/u=4247656867,4135832390&amp;fm=11&amp;fmt=auto&amp;gp=0.jpg&#x27;, ] 然后将值传入 1234let res = await createAvatar(&#123; canvasId: this.canvasId, data: imgs &#125;) 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556## 基本用法 ```html &lt;template&gt; &lt;view&gt; &lt;button type=&quot;primary&quot; @tap=&quot;cerate&quot;&gt;创建群组头像&lt;/button&gt; &lt;canvas :canvas-id=&quot;canvasId&quot; style=&quot;width: 120px; height: 120px; margin: 36px auto;&quot;&gt;&lt;/canvas&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import createAvatar from &#x27;@/uni_modules/ch-avatar/js_sdk/index.js&#x27; export default &#123; data() &#123; return &#123; canvasId: &#x27;canvas&#x27; &#125; &#125;, onLoad() &#123;&#125;, methods: &#123; async cerate() &#123; let imgs = [ &#x27;https://img0.baidu.com/it/u=3101694723,748884042&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, &#x27;https://img2.baidu.com/it/u=3566088443,3713209594&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, &#x27;https://img1.baidu.com/it/u=1361135963,570304265&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, &#x27;https://img1.baidu.com/it/u=2496571732,442429806&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, //这个链接是错的，为了体现获取图片错误时会获取本地默认图片 &#x27;https://img2.baidu.com/it/u=4247656867,4135832390&amp;fm=11&amp;fmt=auto&amp;gp=0.jpg&#x27;, &#x27;https://img0.baidu.com/it/u=3438413553,834879777&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, &#x27;https://img2.baidu.com/it/u=3681880960,455182084&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, &#x27;https://img2.baidu.com/it/u=3681880960,455182084&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, &#x27;https://img2.baidu.com/it/u=3681880960,455182084&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg&#x27;, ] let res = await createAvatar(&#123; canvasId: this.canvasId, data: imgs &#125;) console.log(res); &#125; &#125; &#125; &lt;/script&gt; ``` ## 启动方式 1. 属性isShow被赋值为true 2. `this.$refs.myDTPicker.show()` ## 属性 | 属性 | 描述 | 类型 | 默认值 | |--|--|--|--| | canvasId| canvas的canvas-id | String | canvas| | data| 图片集合 | Array| [] | | width| 生成图片的宽度,默认高度等于宽度 | Number | 120 | | bgColor| 生成图片的背景色 | String | #cecece | | gutter| 图片中间间距 | Number | 6 | | margin| 图片边距 | Number | 6 |","path":"2022/01/17/实现微信群聊头像效果/","date":"01-17","excerpt":"","tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://wanwan-doudou/github.io/tags/uniapp/"}]},{"title":"vm.$nextTick( [callback] )","text":"在项目开发中，经常会遇到这样的场景。通过ajax获取到数据后，我们要去渲染dom或者初始化列表使用的滚动插件。 当数据没有渲染完成，就去获取DOM节点，这样是获取不到的 参数：{Function} [callback] 用法：将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。 示例： 12345678910111213141516new Vue(&#123; // ... methods: &#123; // ... example: function () &#123; // 修改数据 this.message = &#x27;changed&#x27; // DOM 还没有更新 this.$nextTick(function () &#123; // DOM 现在更新了 // `this` 绑定到当前实例 this.doSomethingElse() &#125;) &#125; &#125; &#125;) 1234this.$nextTick(() =&gt; &#123; this.collItemCalcHeight(index); this.calcHeight(); &#125;);","path":"2022/01/13/vm.$nextTick( [callback] )/","date":"01-13","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"https://wanwan-doudou/github.io/tags/vue/"}]},{"title":"uView Collapse折叠面板","text":"快速上手 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;u-collapse @change=&quot;change&quot; @close=&quot;close&quot; @open=&quot;open&quot; &gt; &lt;u-collapse-item title=&quot;第一个折叠面板&quot; name=&quot;first&quot; &gt; &lt;text class=&quot;u-collapse-content&quot;&gt;第一条内容&lt;/text&gt; &lt;/u-collapse-item&gt; &lt;u-collapse-item title=&quot;第二个折叠面板&quot; name=&quot;second&quot; &gt; &lt;text class=&quot;u-collapse-content&quot;&gt;第二条内容&lt;/text&gt; &lt;/u-collapse-item&gt; &lt;u-collapse-item title=&quot;第三个折叠面板&quot; name=&quot;third&quot; &gt; &lt;text class=&quot;u-collapse-content&quot;&gt;第三条内容&lt;/text&gt; &lt;/u-collapse-item&gt; &lt;/u-collapse&gt; &lt;/template&gt; &lt;script&gt; export default &#123; methods: &#123; open(e) &#123; console.log(&#x27;open&#x27;, e) &#125;, close(e) &#123; console.log(&#x27;close&#x27;, e) &#125;, change(e) &#123; console.log(&#x27;change&#x27;, e) &#125; &#125; &#125; &lt;/script&gt; Collapse Item Props Collapse Event","path":"2022/01/12/uView-Collapse折叠面板/","date":"01-12","excerpt":"","tags":[{"name":"uView","slug":"uView","permalink":"https://wanwan-doudou/github.io/tags/uView/"}]},{"title":"echarts赋值","text":"饼图： 123456789101112131415161718192021222324252627282930313233343536373839404142var lowerRightChart = echarts.init(document.getElementById(&#x27;lowerRightChart&#x27;)); option = &#123; tooltip: &#123; trigger: &#x27;item&#x27; &#125;, legend: &#123; top: &#x27;5%&#x27;, left: &#x27;center&#x27; &#125;, title: &#123; text: &#x27;统计&#x27;, &#125;, series: [ &#123; name: &#x27;Statistics&#x27;, type: &#x27;pie&#x27;, radius: [&#x27;40%&#x27;, &#x27;70%&#x27;], avoidLabelOverlap: false, itemStyle: &#123; borderRadius: 10, borderColor: &#x27;#fff&#x27;, borderWidth: 2 &#125;, label: &#123; show: false, position: &#x27;center&#x27; &#125;, emphasis: &#123; label: &#123; show: true, fontSize: &#x27;40&#x27;, fontWeight: &#x27;bold&#x27; &#125; &#125;, labelLine: &#123; show: false &#125;, data: monthly &#125; ] &#125;; lowerRightChart.setOption(option); 在异步获取到数据后赋值到饼图上去。 1234567891011121314151617181920212223242526272829303132333435$.ajax(&#123; url: &#x27;&#x27; , success(suc) &#123; option.series = [ &#123; name: &#x27;Statistics&#x27;, type: &#x27;pie&#x27;, radius: [&#x27;40%&#x27;, &#x27;70%&#x27;], avoidLabelOverlap: false, itemStyle: &#123; borderRadius: 10, borderColor: &#x27;#fff&#x27;, borderWidth: 2 &#125;, label: &#123; show: false, position: &#x27;center&#x27; &#125;, emphasis: &#123; label: &#123; show: true, fontSize: &#x27;40&#x27;, fontWeight: &#x27;bold&#x27; &#125; &#125;, labelLine: &#123; show: false &#125;, data: monthly &#125; ] lowerRightChart.clear(); lowerRightChart.setOption(option); &#125; &#125;)","path":"2022/01/11/echarts赋值/","date":"01-11","excerpt":"","tags":[{"name":"echarts","slug":"echarts","permalink":"https://wanwan-doudou/github.io/tags/echarts/"}]},{"title":"vue使用踩坑","text":"12345678layui.use(() =&gt; &#123; let vue = new Vue(&#123; el: &#x27;#member-category-app&#x27;, data: &#123; noData: true &#125; &#125;) &#125; 我在下面方法中给noData赋值时用了this.noData导致赋值失败 12345if (res.data.records.length &gt; 0) &#123; this.noData = false; &#125; else &#123; this.noData = true; &#125; 正确写法应该是这样 12345if (res.data.records.length &gt; 0) &#123; vue.noData = false; &#125; else &#123; vue.noData = true; &#125;","path":"2022/01/10/vue使用踩坑/","date":"01-10","excerpt":"","tags":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://wanwan-doudou/github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}]},{"title":"uni-app 监听和触发全局自定义事件","text":"uni.$emit(eventName,OBJECT)触发全局的自定义事件，附加参数都会传给监听器回调函数。 eventName:事件名，String类型 OBJEC:触发事件携带的附加参数,Object类型 示例： 123like(msg)&#123; uni.$emit(&#x27;like&#x27;, msg) &#125;, uni.$on(eventName,callback) 监听全局的自定义事件，事件由 uni.$emit 触发，回调函数会接收事件触发函数的传入参数。 eventName: 事件名，String类型 callback: 事件的回调函数，Function类型 示例： 1234uni.$on(&#x27;like&#x27;, this.like); like(msg) &#123; console.log(msg); &#125;","path":"2022/01/08/uni-app-监听和触发全局自定义事件/","date":"01-08","excerpt":"","tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://wanwan-doudou/github.io/tags/uniapp/"}]},{"title":"uni-app数据缓存","text":"uni.setStorageSync(key,data)将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。 示例： 1uni.setStorageSync(&#x27;name&#x27;,&#x27;kwydy&#x27;) 这里的”name”是本地缓存中指定的key 这里的”kwydy”是需要存储的内容 123456newDynamicLike(msg) &#123; this.user = msg; let users = uni.getStorageSync(&#x27;users&#x27;)||[] users.push(this.user) uni.setStorageSync(&#x27;users&#x27;,users) &#125;, uni.getStorageSync(key) 从本地缓存中同步获取指定 key 对应的内容。 这里的”users”是从本地缓存中同步获取指定 key 对应的内容。","path":"2022/01/07/uni-app数据缓存/","date":"01-07","excerpt":"","tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://wanwan-doudou/github.io/tags/uniapp/"}]},{"title":"使用uni.navigateTo()传递对象","text":"1.跳转页面 1234567891011121314data() &#123; return &#123; dynamicLike: &#123;&#125;, &#125; &#125; methods: &#123; toRemind() &#123; let obj = JSON.stringify(this.dynamicLike); uni.navigateTo(&#123; url: &#x27;/pages/square/remind?obj=&#x27; + encodeURIComponent(obj) &#125;); this.judge = false; &#125;, &#125; 2.接受界面 1234onLoad(options) &#123; this.userInfo = JSON.parse(decodeURIComponent(options.obj)); console.log(this.userInfo); &#125;,","path":"2022/01/06/使用uni-navigateTo-传递对象/","date":"01-06","excerpt":"","tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://wanwan-doudou/github.io/tags/uniapp/"}]},{"title":"Opt非空判断","text":"1234567891011121314151617181920List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(1); list.add(1); // 判断一个list是否为空，如果不为空判断是否包含元素，如果包含元素获取它的长度，否则返回0 Integer integer = Opt.ofEmptyAble(list).map(List::size).orElse(0); System.out.println(integer); // 如果值不为空则打印，否则为空 String z = Opt.ofBlankAble(&quot;值不为空&quot;).peek(System.out::println).orElse(&quot;kwydy&quot;); String s = Opt.ofBlankAble(&quot;&quot;).peek(System.out::println).orElse(&quot;kwydy&quot;); System.out.println(s); //如果值不为空则打印a,否则输出“我没有值” String a = null; Opt.ofNullable(a).ifPresentOrElse(s1 -&gt; &#123; System.out.println(s1); &#125;, () -&gt; &#123; System.out.println(&quot;我没有值&quot;); &#125;);","path":"2022/01/04/Opt非空判断/","date":"01-04","excerpt":"","tags":[{"name":"Opt","slug":"Opt","permalink":"https://wanwan-doudou/github.io/tags/Opt/"}]},{"title":"Stream流(1)","text":"概述Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。 数据准备123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; @Data @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode//用于后期的去重使用 public class Author &#123; //id private Long id; //姓名 private String name; //年龄 private Integer age; //简介 private String intro; //作品 private List&lt;Book&gt; books; &#125; @Data @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode public class Book &#123; //id private Long id; //书名 private String name; //分类 private String category; //评分 private Integer score; //简介 private String intro; &#125; public class StreamDemo &#123; public static void main(String[] args) &#123; List&lt;Author&gt; authors = getAuthors(); System.out.println(authors); &#125; private static List&lt;Author&gt; getAuthors() &#123; //数据初始化 Author author = new Author(1L, &quot;蒙多&quot;, 33, &quot;一个从才多种明悟哲理的祖安人&quot;, null); Author author2 = new Author(2L, &quot;亚拉索&quot;, 15, &quot;狂风也追逐不上他的思考宿舍的&quot;, null); Author author3 = new Author(3L, &quot;易&quot;, 14, &quot;是这个世界在限制他的思维&quot;, null); Author author4 = new Author(4L, &quot;易&quot;, 14, &quot;是这个世界在限制他的思维&quot;, null); //书籍列表 List&lt;Book&gt; books1 = new ArrayList&lt;&gt;(); List&lt;Book&gt; books2 = new ArrayList&lt;&gt;(); List&lt;Book&gt; books3 = new ArrayList&lt;&gt;(); books1.add(new Book(1L, &quot;刀的两侧式光明与黑暗&quot;, &quot;哲学,爱情&quot;, 88, &quot;用一把刀划分了爱恨&quot;)); books1.add(new Book(2L, &quot;一个人不能死在同一把刀下&quot;, &quot;个人成长,爱情&quot;, 99, &quot;讲述如何从失败&quot;)); books2.add(new Book(3L, &quot;那风吹不到的地方&quot;, &quot;哲学&quot;, 85, &quot;带你用思维去领略世界的尽头&quot;)); books2.add(new Book(3L, &quot;那风吹不到的地方&quot;, &quot;哲学&quot;, 85, &quot;带你用思维去领略世界的尽头&quot;)); books2.add(new Book(4L, &quot;吹或不吹&quot;, &quot;爱情，个人传记&quot;, 56, &quot;一个哲学家的恋爱观注定很难把他&quot;)); books2.add(new Book(5L, &quot;你的剑就是我的剑&quot;, &quot;爱情&quot;, 56, &quot;无法想象一个武者能对他的伴侣&quot;)); books2.add(new Book(6L, &quot;风与剑&quot;, &quot;个人传记&quot;, 100, &quot;两个哲学家灵魂和肉体的碰撞会激起怎么&quot;)); books2.add(new Book(6L, &quot;风与剑&quot;, &quot;个人传记&quot;, 100, &quot;两个哲学家灵魂和肉体的碰撞会激起怎么&quot;)); author.setBooks(books1); author2.setBooks(books2); author3.setBooks(books3); author4.setBooks(books3); List&lt;Author&gt; authorList = new ArrayList&lt;&gt;(Arrays.asList(author, author2, author3, author4)); return authorList; &#125; &#125; 需求我们可以效用getAuthors方法获取刀作家的集合。现在需要打印多有年龄小于18作家 的名字，并且要注意去重。 实现123456List&lt;Author&gt; authors = getAuthors(); //把集合转换成流 authors.stream() .distinct()//去重0【 .filter(author -&gt; author.getAge() &lt; 18) .forEach(author -&gt; System.out.println(author.getName())); 常用操作创建流单例集合：集合对象.stream() 12List&lt;Author&gt; authors = getAuthors(); Stream&lt;Author&gt; stream = authors.stream(); 数组：Arrays.stream(数组)或者使用Stream.of来创建 123Integer arr[] = &#123;1, 2, 3, 4, 5&#125;; Stream&lt;Integer&gt; stream = Arrays.stream(arr) Stream&lt;Integer&gt; stream2 = Stream.of(arr); 双列集合： 123456789Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;蜡笔小新&quot;, 19); map.put(&quot;黑子&quot;, 17); map.put(&quot;日向翔阳&quot;, 16); Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet(); Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = entries.stream(); stream.filter(entry -&gt; entry.getValue()&gt;16) .forEach(entry -&gt; System.out.println(entry.getKey() + &quot;===&quot; + entry.getValue()));","path":"2022/01/03/Stream流-1/","date":"01-03","excerpt":"","tags":[{"name":"stream","slug":"stream","permalink":"https://wanwan-doudou/github.io/tags/stream/"}]},{"title":"图片懒加载","text":"上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .kwydy &#123; width: 300px; height: 400px; &#125; .kwydy img &#123; width: 100%; height: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3059_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3058_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3057_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3056_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3055_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3054_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3053_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3052_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3051_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3050_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3049_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3048_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3047_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3049_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3045_3.jpg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;kwydy&quot;&gt;&lt;img data-src=&quot;https://kwydy.gitee.io/imgs/preview/3044_3.jpg&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; let lazyLoading = document.querySelectorAll(&quot;img&quot;) function lazyLoad() &#123; // 获取屏幕可视区域高度 let visualHeight = document.documentElement.clientHeight; // 遍历图片 lazyLoading.forEach(e =&gt; &#123; if (!e.src) &#123; // getBoundingClientRect()用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。 let rect = e.getBoundingClientRect() if (rect.top &lt; visualHeight) &#123; e.src = e.dataset.src &#125; &#125; &#125;) // 滚动时加载 window.onscroll ?? = lazyLoad &#125; lazyLoad() &lt;/script&gt; &lt;/html&gt;","path":"2022/01/02/图片懒加载/","date":"01-02","excerpt":"","tags":[{"name":"前端","slug":"前端","permalink":"https://wanwan-doudou/github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"orderBy排序，null在最后面","text":"我们进行排序查询时： 1SELECT * FROM `user` ORDER BY username 可以看到null值排到了最上 如果我们要将null值排到最下方可以使用： 1SELECT * FROM `user` ORDER BY ISNULL(username),username 执行结果： 这是因为ISNULL函数将其转换为了0和1，我们可以顺带查询出来看看： 1SELECT *,ISNULL(username) FROM `user` ORDER BY ISNULL(username),username","path":"2022/01/01/orderBy排序，null在最后面/","date":"01-01","excerpt":"","tags":[{"name":"数据库","slug":"数据库","permalink":"https://wanwan-doudou/github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"JavaScript 赋值问题","text":"12345let name = &#x27;kwydy&#x27; let aj = &#123;data:name&#125; console.log(aj) name = &#x27;zgajbtcm&#x27; console.log(aj) 可以看到aj还是为’kwydy’ 我们需要再赋值一次 123456let name = &#x27;kwydy&#x27; let aj = &#123;data:name&#125; console.log(aj) name = &#x27;zgajbtcm&#x27; aj = &#123;data:name&#125; console.log(aj)","path":"2021/12/31/JavaScript-赋值问题/","date":"12-31","excerpt":"","tags":[{"name":"前端","slug":"前端","permalink":"https://wanwan-doudou/github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"element Carousel走马灯","text":"首先引入js和css 1234&lt;!-- 引入样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; 接着引入vue 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; 快速上手 12345678&lt;!-- 轮播图 --&gt; &lt;section class=&quot;banner&quot;&gt; &lt;el-carousel&gt; &lt;el-carousel-item v-for=&quot;(item,index) in imgs&quot; :key=&quot;index&quot;&gt; &lt;img :src=&quot;item.src&quot; alt=&quot;轮播图&quot;&gt; &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;/section&gt; 12345678&lt;script th:inline=&quot;javascript&quot;&gt; let vue = new Vue(&#123; el: &quot;#app&quot; , data: &#123; imgs: [[$&#123;contentBanner&#125;]] &#125; &#125;); &lt;/script&gt; 效果如下 这是具体参数和事件","path":"2021/12/29/element-Carousel走马灯/","date":"12-29","excerpt":"","tags":[{"name":"element","slug":"element","permalink":"https://wanwan-doudou/github.io/tags/element/"}]},{"title":"element Pagination 分页","text":"首先引入js和css 1234&lt;!-- 引入样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt; &lt;!-- 引入组件库 --&gt; &lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; 快速上手 12345&lt;el-pagination background layout=&quot;prev, pager, next&quot; :total=&quot;1000&quot;&gt; &lt;/el-pagination&gt; 效果如下： 具体参数如下：","path":"2021/12/28/element-Pagination-分页/","date":"12-28","excerpt":"","tags":[{"name":"element","slug":"element","permalink":"https://wanwan-doudou/github.io/tags/element/"}]},{"title":"hutool LocalDateTime工具","text":"根据时间统计每天的登记数 但我们这个时候不需要时分秒，我们可以使用hutool中的LocalDateTime工具进行日期格式化 实例： 1Map&lt;String, Long&gt; collect = clockRecords.stream().collect(Collectors.groupingBy(clockRecord -&gt; LocalDateTimeUtil.format(clockRecord.getGmtCreate(), DatePattern.NORM_DATE_PATTERN), Collectors.counting())); 除此之外LocalDateTime还有以下用法 日期转换 12345678String dateStr = &quot;2020-01-23T12:23:56&quot;; DateTime dt = DateUtil.parse(dateStr); // Date对象转换为LocalDateTime LocalDateTime of = LocalDateTimeUtil.of(dt); // 时间戳转换为LocalDateTime of = LocalDateTimeUtil.ofUTC(dt.getTime()); 2.日期字符串解析 1234// 解析ISO时间 LocalDateTime localDateTime = LocalDateTimeUtil.parse(&quot;2020-01-23T12:23:56&quot;); // 解析自定义格式时间 localDateTime = LocalDateTimeUtil.parse(&quot;2020-01-23&quot;, DatePattern.NORM_DATE_PATTERN); 3.计算时间间隔 1234567LocalDateTime start = LocalDateTimeUtil.parse(&quot;2019-02-02T00:00:00&quot;); LocalDateTime end = LocalDateTimeUtil.parse(&quot;2020-02-02T00:00:00&quot;); Duration between = LocalDateTimeUtil.between(start, end); // 365 between.toDays();","path":"2021/12/27/hutool-LocalDateTime工具/","date":"12-27","excerpt":"","tags":[{"name":"hutool","slug":"hutool","permalink":"https://wanwan-doudou/github.io/tags/hutool/"}]},{"title":"Port 8080 was already in use.","text":"踩坑 2021-12-26 今天启动项目时出现了这样一个错误，导致项目启动失败 我们打开任务管理器关闭java","path":"2021/12/26/Port-8080-was-already-in-use/","date":"12-26","excerpt":"","tags":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://wanwan-doudou/github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}]},{"title":"正则表达式","text":"正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 实例从字符串 str 中提取数字部分的内容(匹配一次)： 123var str = &quot;abc123def&quot;; var patt1 = /[0-9]+/; document.write(str.match(patt1)); 结果输出：123 比如我们要获取这个字符串：data-v-04699762&#x3D;”” 我们可以这么写：(data-v-[0-9]+&#x3D;””)","path":"2021/12/24/正则表达式/","date":"12-24","excerpt":"","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://wanwan-doudou/github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"git合并、变基","text":"在团队开发中不免会遇到代码冲突 idea解决冲突方式如下 首先遇到冲突时idea会提醒 我们点击Merge后可以看到发生冲突的文件全都列出了 我们再次点击右边的合并(英文是Merge) 左边是我们本地的版本，右边是git仓库上的版本，中间则是我们需要修改成的版本 我们可以点击左下角的 接受左侧（本地覆盖服务器） 接受右侧（服务器覆盖本地） 或者在中间部分调整出最后想要的结果然后点击右下角的应用 如果弹出 我们只需要再提交一遍代码就好了 正常企业开发git提交操作为 写好代码-&gt;提交到本地仓库(commit)**-&gt;拉取远程仓库代码(pull)-&gt;解决冲突-&gt;**推送到远程仓库(push)","path":"2021/12/22/git合并、变基/","date":"12-22","excerpt":"","tags":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://wanwan-doudou/github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}]},{"title":"Vue子组件给父组件传值","text":"子组件向父组件传值 1.在子组件中创建一个按钮，给按钮绑定一个点击事件 在响应该点击事件的函数中使用$emit来触发一个自定义事件，并传递一个参数 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;button type=&quot;button&quot; @click=&quot;sendToMessageParent&quot;&gt;向父组件传值&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: &#x27;emit&#x27;, props: &#123; msg: &#123; type:String, default:&quot;莫瑞诺&quot; &#125; &#125;, methods: &#123; sendToMessageParent: function() &#123; this.$emit(&#x27;listToChild&#x27;, &#x27;你好父组件&#x27;); &#125; &#125; &#125;; &lt;/script&gt; &lt;style&gt;&lt;/style&gt; 2.在父组件中的子标签中监听该自定义事件并添加一个响应该事件的处理方法 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt;&lt;emit v-on:listToChild=&quot;show&quot;&gt;&lt;/emit&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; // import emit from &#x27;@/components/emit/emit.vue&#x27;; import emit from &quot;../../components/emit/emit.vue&quot; export default &#123; name: &#x27;app&#x27;, components: &#123; emit, &#125;, data() &#123; return &#123; age:&#x27;18&#x27; &#125;; &#125;, methods: &#123; show: function(data) &#123; console.log(&quot;123&quot;) console.log(data) &#125; &#125; &#125;; &lt;/script&gt; &lt;style&gt;&lt;/style&gt; 这是运行结果","path":"2021/12/21/vue子组件给父组件传值/","date":"12-21","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"https://wanwan-doudou/github.io/tags/vue/"}]},{"title":"layui分页模块","text":"快速使用 laypage 的使用非常简单，指向一个用于存放分页的容器，通过服务端得到一些初始值，即可完成分页渲染： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;layPage快速使用&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/build/layui.css&quot; media=&quot;all&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;test1&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/static/build/layui.js&quot;&gt;&lt;/script&gt; &lt;script&gt; layui.use(&#x27;laypage&#x27;, function()&#123; var laypage = layui.laypage; //执行一个laypage实例 laypage.render(&#123; elem: &#x27;test1&#x27; //注意，这里的 test1 是 ID，不用加 # 号 ,count: 50 //数据总数，从服务端得到 &#125;); &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 当分页被切换时触发，函数返回两个参数：_obj_（当前分页的所有选项值）、first（是否首次，一般用于初始加载的判断） 1234567891011121314laypage.render(&#123; elem: &#x27;test1&#x27; ,count: 70 //数据总数，从服务端得到 ,jump: function(obj, first)&#123; //obj包含了当前分页的所有参数，比如： console.log(obj.curr); //得到当前页，以便向服务端请求对应页的数据。 console.log(obj.limit); //得到每页显示的条数 //首次不执行 if(!first)&#123; //do something &#125; &#125; &#125;);","path":"2021/12/20/layui分页模块/","date":"12-20","excerpt":"","tags":[{"name":"layui","slug":"layui","permalink":"https://wanwan-doudou/github.io/tags/layui/"}]},{"title":"mybatis-plus代码生成器","text":"导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.ruben; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.generator.FastAutoGenerator; import com.baomidou.mybatisplus.generator.config.DataSourceConfig; import com.baomidou.mybatisplus.generator.config.TemplateType; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import org.junit.jupiter.api.Test; /** * 生成器配置 * * @author &lt;achao1441470436@gmail.com&gt; * @since 2021/10/5 16:38 */ public class GeneratorTests &#123; /** * 生成代码的表名 */ private static final String TABLE_NAME = &quot;user_info&quot;; /** * 数据库相关配置 */ private static final String JDBC_URL = &quot;jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;nullCatalogMeansCurrent=true&amp;serverTimezone=Asia/Shanghai&quot;; private static final String USERNAME = &quot;root&quot;; private static final String PASSWORD = &quot;root&quot;; /** * 注释显示的作者 */ private static final String AUTHOR = &quot;&lt;achao1441470436@gmail.com&gt;&quot;; /** * 代码生成指定包名 */ private static final String PACKAGE_NAME = &quot;com.ruben&quot;; /** * 指定代码生成路径 */ private static final String OUTPUT_DIR = &quot;D:\\\\file\\\\tmp\\\\generator\\\\output&quot;; /** * 模板存放路径 */ private static final String TEMPLATE_PATH = &quot;./static/generator/&quot;; @Test public void generate() &#123; System.out.println(OUTPUT_DIR); FastAutoGenerator.create(new DataSourceConfig.Builder(JDBC_URL, USERNAME, PASSWORD)) // 全局配置 .globalConfig(builder -&gt; builder.author(AUTHOR).fileOverride().outputDir(OUTPUT_DIR)) // 包配置 .packageConfig(builder -&gt; builder.parent(PACKAGE_NAME)) // 策略配置 .strategyConfig(builder -&gt; builder // 指定表名，如不指定，则默认生成所有 // .addInclude(TABLE_NAME) .controllerBuilder().enableRestStyle() .serviceBuilder() .entityBuilder() // 指定父类 .superClass(PACKAGE_NAME + &quot;.pojo.common.BaseEntity&quot;) // 添加父类字段 .addSuperEntityColumns(&quot;is_deleted&quot;, &quot;gmt_create&quot;, &quot;gmt_modified&quot;, &quot;tenant_id&quot;) // 开启AR模式 .enableActiveRecord() // ID类型，这里IdType是个枚举 .idType(IdType.AUTO) // 表名命名转换，这里是下划线转驼峰 .naming(NamingStrategy.underline_to_camel) // 表字段名转换，下划线转驼峰 .columnNaming(NamingStrategy.underline_to_camel) // 开启lombok .enableLombok() // 开启链式编程 （与BeanCopier冲突） .enableChainModel()) // 不生成xml .templateConfig(builder -&gt; builder.disable(TemplateType.XML) .controller(TEMPLATE_PATH + &quot;controller.java.vm&quot;) .entity(TEMPLATE_PATH + &quot;entity.java.vm&quot;) .mapper(TEMPLATE_PATH + &quot;mapper.java.vm&quot;) .service(TEMPLATE_PATH + &quot;service.java.vm&quot;) .serviceImpl(TEMPLATE_PATH + &quot;serviceImpl.java.vm&quot;) ) // 自定义模板位置 .execute(); &#125; &#125; 以及自己使用的controller的模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package $&#123;package.Controller&#125;; #if($&#123;restControllerStyle&#125;) import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.core.toolkit.Wrappers; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.ruben.pojo.common.Result; import $&#123;package.Entity&#125;.$&#123;entity&#125;; import $&#123;package.Service&#125;.$&#123;table.serviceName&#125;; import org.springframework.validation.annotation.Validated; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; #else import org.springframework.stereotype.Controller; #end #if($&#123;superControllerClassPackage&#125;) import $&#123;superControllerClassPackage&#125;; #end /** * &lt;p&gt; * $!&#123;table.comment&#125; 前端控制器 * &lt;/p&gt; * * @author $&#123;author&#125; * @since $&#123;date&#125; */ #if($&#123;restControllerStyle&#125;) @RestController #else @Controller #end @RequestMapping(&quot;#if($&#123;package.ModuleName&#125;)/$&#123;package.ModuleName&#125;#end/#if($&#123;controllerMappingHyphenStyle&#125;)$&#123;controllerMappingHyphen&#125;#else$&#123;table.entityPath&#125;#end&quot;) #if($&#123;kotlin&#125;) class $&#123;table.controllerName&#125;#if($&#123;superControllerClass&#125;) : $&#123;superControllerClass&#125;()#end #else #if($&#123;superControllerClass&#125;) public class $&#123;table.controllerName&#125; extends $&#123;superControllerClass&#125; &#123; #else public class $&#123;table.controllerName&#125; &#123; #end #set($serviceBeanName = $table.serviceName.substring(1,2).toLowerCase() + $table.serviceName.substring(2)) #set($entityName = $entity.substring(0,1).toLowerCase() + $entity.substring(1)) @Resource private $&#123;table.serviceName&#125; $&#123;serviceBeanName&#125;; /** * 查询单条记录 * * @param id 主键 * @return 记录 * @since $&#123;date&#125; * @author $&#123;author&#125; */ @GetMapping public Result get(@RequestParam(&quot;id&quot;) Long id)&#123; return Result.ok().data($&#123;entity&#125;.builder().build().setId(id).selectById()); &#125; /** * 查询列表 * * @param page 分页参数?size=10&amp;current=1 * @return 分页结果 * @since $&#123;date&#125; * @author $&#123;author&#125; */ @GetMapping(&quot;page&quot;) public Result page(Page&lt;$&#123;entity&#125;&gt; page, $&#123;entity&#125; $&#123;entityName&#125;)&#123; return Result.ok().data($&#123;entityName&#125;.selectPage(page,Wrappers.lambdaQuery($&#123;entityName&#125;))); &#125; /** * 新增 * * @param $&#123;entityName&#125; 数据 * @since $&#123;date&#125; * @author $&#123;author&#125; */ @PostMapping public Result insert(@RequestBody @Validated $&#123;entity&#125; $&#123;entityName&#125;)&#123; $&#123;entityName&#125;.insert(); return Result.ok(); &#125; /** * 更新不为null的部分 * * @param $&#123;entityName&#125; 数据 * @since $&#123;date&#125; * @author $&#123;author&#125; */ @PatchMapping public Result updateSelective(@RequestBody @Validated $&#123;entity&#125; $&#123;entityName&#125;)&#123; $&#123;entityName&#125;.updateById(); return Result.ok(); &#125; /** * 根据主键删除 * * @param id 主键 * @since $&#123;date&#125; * @author $&#123;author&#125; */ @DeleteMapping public Result delete(@RequestParam(&quot;id&quot;) Long id)&#123; $&#123;entity&#125;.builder().build().setId(id).deleteById(); return Result.ok(); &#125; &#125; #end entity的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package $&#123;package.Entity&#125;; #foreach($pkg in $&#123;table.importPackages&#125;) import $&#123;pkg&#125;; #end #if($&#123;swagger2&#125;) import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; #end #if($&#123;entityLombokModel&#125;) import lombok.*; #if($&#123;chainModel&#125;) import lombok.experimental.Accessors; #end #end /** * &lt;p&gt; * $!&#123;table.comment&#125; * &lt;/p&gt; * * @author $&#123;author&#125; * @since $&#123;date&#125; */ #if($&#123;entityLombokModel&#125;) @Data @Builder @NoArgsConstructor @AllArgsConstructor #if($&#123;chainModel&#125;) @Accessors(chain = true) #end #if($&#123;superEntityClass&#125;) @EqualsAndHashCode(callSuper = true) #else @EqualsAndHashCode(callSuper = false) #end #end #if($&#123;table.convert&#125;) @TableName(&quot;$&#123;table.name&#125;&quot;) #end #if($&#123;swagger2&#125;) @ApiModel(value = &quot;$&#123;entity&#125;对象&quot;, description = &quot;$!&#123;table.comment&#125;&quot;) #end #if($&#123;superEntityClass&#125;) public class $&#123;entity&#125; extends $&#123;superEntityClass&#125;#if($&#123;activeRecord&#125;)&lt;$&#123;entity&#125;&gt;#end &#123; #elseif($&#123;activeRecord&#125;) public class $&#123;entity&#125; extends Model&lt;$&#123;entity&#125;&gt; &#123; #else public class $&#123;entity&#125; implements Serializable&#123; #end #if($&#123;entitySerialVersionUID&#125;) private static final long serialVersionUID=1L; #end ## ---------- BEGIN 字段循环遍历 ---------- #foreach($field in $&#123;table.fields&#125;) #if($&#123;field.keyFlag&#125;) #set($keyPropertyName=$&#123;field.propertyName&#125;) #end #if(&quot;$!field.comment&quot; != &quot;&quot;) #if($&#123;swagger2&#125;) @ApiModelProperty(value = &quot;$&#123;field.comment&#125;&quot;) #else /** * $&#123;field.comment&#125; */ #end #end #if($&#123;field.keyFlag&#125;) ## 主键 #if($&#123;field.keyIdentityFlag&#125;) @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.AUTO) #elseif(!$null.isNull($&#123;idType&#125;) &amp;&amp; &quot;$!idType&quot; != &quot;&quot;) @TableId(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, type = IdType.$&#123;idType&#125;) #elseif($&#123;field.convert&#125;) @TableId(&quot;$&#123;field.annotationColumnName&#125;&quot;) #end ## 普通字段 #elseif($&#123;field.fill&#125;) ## ----- 存在字段填充设置 ----- #if($&#123;field.convert&#125;) @TableField(value = &quot;$&#123;field.annotationColumnName&#125;&quot;, fill = FieldFill.$&#123;field.fill&#125;) #else @TableField(fill = FieldFill.$&#123;field.fill&#125;) #end #elseif($&#123;field.convert&#125;) @TableField(&quot;$&#123;field.annotationColumnName&#125;&quot;) #end ## 乐观锁注解 #if($&#123;field.versionField&#125;) @Version #end ## 逻辑删除注解 #if($&#123;field.logicDeleteField&#125;) @TableLogic #end private $&#123;field.propertyType&#125; $&#123;field.propertyName&#125;; #end ## ---------- END 字段循环遍历 ---------- #if(!$&#123;entityLombokModel&#125;) #foreach($field in $&#123;table.fields&#125;) #if($&#123;field.propertyType.equals(&quot;boolean&quot;)&#125;) #set($getprefix=&quot;is&quot;) #else #set($getprefix=&quot;get&quot;) #end public $&#123;field.propertyType&#125; $&#123;getprefix&#125;$&#123;field.capitalName&#125;()&#123; return $&#123;field.propertyName&#125;; &#125; #if($&#123;chainModel&#125;) public $&#123;entity&#125; set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;)&#123; #else public void set$&#123;field.capitalName&#125;($&#123;field.propertyType&#125; $&#123;field.propertyName&#125;) &#123; #end this.$&#123;field.propertyName&#125; = $&#123;field.propertyName&#125;; #if($&#123;chainModel&#125;) return this; #end &#125; #end ## --foreach end--- #end ## --end of #if(!$&#123;entityLombokModel&#125;)-- #if($&#123;entityColumnConstant&#125;) #foreach($field in $&#123;table.fields&#125;) public static final String $&#123;field.name.toUpperCase()&#125; =&quot;$&#123;field.name&#125;&quot;; #end #end #if($&#123;activeRecord&#125; &amp;&amp; !$&#123;superEntityClass&#125; ) @Override protected Serializable pkVal()&#123; #if($&#123;keyPropertyName&#125;) return this.$&#123;keyPropertyName&#125;; #else return null; #end &#125; #end #if(!$&#123;entityLombokModel&#125;) @Override public String toString() &#123; return &quot;$&#123;entity&#125;&#123;&quot; + #foreach($field in $&#123;table.fields&#125;) #if($!&#123;foreach.index&#125;==0) &quot;$&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; + #else &quot;, $&#123;field.propertyName&#125;=&quot; + $&#123;field.propertyName&#125; + #end #end &quot;&#125;&quot;; &#125; #end &#125;","path":"2021/12/18/mybatis-plus代码生成器/","date":"12-18","excerpt":"","tags":[{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://wanwan-doudou/github.io/tags/mybatis-plus/"}]},{"title":"页面跳转404 路由配置","text":"当我们进行页面跳转时出现404未找到时，有可能是我们忘记配置路由了。 123456789101112/** * 解决发案 * * @return */ @GetMapping(&quot;admin/solution/solution&quot;) public String solution() &#123; // 解决发案 List&lt;ContentBanner&gt; indexSolution = contentBannerService.shufflingFigure(ContentTypeEnum.PROGRAMME); request.setAttribute(AttrKeyConst.PROGRAMME_LINK, indexSolution); return &quot;admin/solution/solution&quot;; &#125;","path":"2021/12/17/页面跳转404-路由配置/","date":"12-17","excerpt":"","tags":[{"name":"前端","slug":"前端","permalink":"https://wanwan-doudou/github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"hutool Opt工具","text":"hutool 非空判断 1234567891011public static void main(String[] args) &#123; List lists = null; // ofEmptyAble(List&lt;T&gt; value) // 返回一个包裹里List集合可能为空的Opt，额外判断了集合内元素为空的情况 Opt.ofEmptyAble(lists).map(list -&gt; &#123; System.out.println(&quot;数据&quot;); return list; // ofEmptyAble(List&lt;T&gt; value) // 返回一个包裹里List集合可能为空的Opt，额外判断了集合内元素为空的情况 &#125;).peek(list -&gt; System.out.println(&quot;list:&quot; + list)); &#125; 可以看到没有数据输出 当我们list有值的时候 1234567891011public static void main(String[] args) &#123; List lists = Arrays.asList(&quot;cat&quot;, &quot;cow&quot;, &quot;dog&quot;); // ofEmptyAble(List&lt;T&gt; value) // 返回一个包裹里List集合可能为空的Opt，额外判断了集合内元素为空的情况 Opt.ofEmptyAble(lists).map(list -&gt; &#123; System.out.println(&quot;数据&quot;); return list; // ofEmptyAble(List&lt;T&gt; value) // 返回一个包裹里List集合可能为空的Opt，额外判断了集合内元素为空的情况 &#125;).peek(list -&gt; System.out.println(&quot;list:&quot; + list)); &#125; list就被打印出来了","path":"2021/12/16/hutool-Opt工具/","date":"12-16","excerpt":"","tags":[{"name":"hutool","slug":"hutool","permalink":"https://wanwan-doudou/github.io/tags/hutool/"}]},{"title":"js取动态key参数","text":"前端 2021-12-16 有一个对象，其中包含若干个子对象，如何如何遍历这个对象中的子对象？ 1234567var data = &#123; 0:&#123;&quot;name&quot;:&#x27;wly&#x27;&#125;, 1:&#123;&quot;name&quot;:&#x27;kwy&#x27;&#125; &#125; for(var item in data )&#123; console.log(data[item].name) &#125;","path":"2021/12/16/js取动态key参数/","date":"12-16","excerpt":"","tags":[{"name":"前端","slug":"前端","permalink":"https://wanwan-doudou/github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"jquery ajax属性async(同步异步)","text":"在jquery的ajax中如果我们希望实现同步或者异步我们可以直接设置async发生为真或假即可true false，下面举几个jquery ajax同步和异步实例 一.什么是同步请求：(false)同步请求即是当前发出请求后，浏览器什么都不能做，必须得等到请求完成返回数据之后，才会执行后续的代码，相当于是排队，前一个人办理完自己的事务，下一个人才能接着办。也就是说，当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，页面处于一个假死状态，当这个AJAX执行完毕后才会继续运行其他代码页面解除假死状态(即当ajax返回数据后，才执行后面的function2)。 二.什么是异步请求：(true) 异步请求就当发出请求的同时，浏览器可以继续做任何事，Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。 一般默认值为true，异步。异步请求可以完全不影响用户的体验效果，无论请求的时间长或者短，用户都在专心的操作页面的其他内容，并不会有等待的感觉。 实例 12345678910&lt;script&gt; $.ajax(&#123; url: &#x27;/contentBanner/page&#x27;, async: false, success() &#123; console.log(&quot;第一次&quot;) &#125; &#125;) console.log(&quot;第二次&quot;) &lt;/script&gt; 12345678910&lt;script&gt; $.ajax(&#123; url: &#x27;/contentBanner/page&#x27;, async: true, success() &#123; console.log(&quot;第一次&quot;) &#125; &#125;) console.log(&quot;第二次&quot;) &lt;/script&gt;","path":"2021/12/16/jquery-ajax属性async-同步异步/","date":"12-16","excerpt":"","tags":[{"name":"jquery","slug":"jquery","permalink":"https://wanwan-doudou/github.io/tags/jquery/"}]},{"title":"vue获取ajax数据并动态渲染","text":"实例 12345678910111213141516171819202122var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; res: [] &#125; &#125;) $(function () &#123; $(&#x27;.carousel&#x27;).carousel(&#123; interval: 5000 &#125;) &#125;); //查询content banner window.onload = function () &#123; $.ajax(&#123; url: &#x27;&#x27;, method: &quot;GET&quot;, success(res) &#123; app.res = res; return res; &#125; &#125;); &#125;; 123&lt;div class=&quot;item&quot; v-for=&quot;(image,index) in res&quot;&gt; &lt;img :src=&quot;image.cover&quot; data-holder-rendered=&quot;true&quot;&gt; &lt;/div&gt;","path":"2021/12/15/vue获取ajax数据并动态渲染/","date":"12-15","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"https://wanwan-doudou/github.io/tags/vue/"}]},{"title":"vue props父组件向子组件传值","text":"props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。 你可以基于对象的语法使用以下选项： type：可以是下列原生构造函数中的一种：String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。 default：any为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。 required：Boolean定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。 validator：Function自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在这里查阅更多 prop 验证的相关信息。 实例 123456789101112131415161718192021//这是子组件 &lt;template&gt; &lt;view&gt; &lt;view&gt;&#123;&#123; name||&#x27;默认值&#x27; &#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default &#123; props: &#123; name: &#123; type: String, default: &#x27;kwydy&#x27;, &#125; &#125;, data() &#123; return &#123;&#125;; &#125;, methods: &#123;&#125; &#125;; &lt;/script&gt; 123456789101112131415161718192021//这是父组件 &lt;template&gt; &lt;view class=&quot;container&quot;&gt; &lt;view&gt;&lt;props :name=&quot;href&quot;&gt;&lt;/props&gt;&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import props from &#x27;@/components/uni-section/props/props.vue&#x27;; export default &#123; components: &#123; props &#125;, data() &#123; return &#123; href: &#x27;https://uniapp.dcloud.io/component/README?id=uniui&#x27; &#125;; &#125;, methods: &#123;&#125; &#125;; &lt;/script&gt; 这是效果图","path":"2021/12/14/vue-props父组件向子组件传值/","date":"12-14","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"https://wanwan-doudou/github.io/tags/vue/"}]},{"title":"es6链判断运算符","text":"今天写项目碰到一个问题，我明确知道这个对象中的有一个属性有值， 但是我获取的时候就报错，后面知道这个地方要使用链判断运算符。 现在我们来学习一下扩展运算符中的链判断运算符。 编程实务中，如果读取内部的某个属性，往往需要判断一下，属性的上层对象是否在。比如，读取message.body.user.firstName这个属性，安全的写法是写成下面这样。 12345678// 错误的写法 const firstName = message.body.user.firstName || &#x27;default&#x27;; // 正确的写法 const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName) || &#x27;default&#x27;; 上面例子中，firstName属性在对象的第四层，所以需要判断四次，每一层是否有值。 三元运算符?:也常用于判断对象是否存在。 12const fooInput = myForm.querySelector(&#x27;input[name=foo]&#x27;) const fooValue = fooInput ? fooInput.value : undefined 上面例子中，必须先判断fooInput是否存在，才能读取fooInput.value。 这样的层层判断非常麻烦，因此 ES2020 引入了“链判断运算符”（optional chaining operator）?.，简化上面的写法。 12const firstName = message?.body?.user?.firstName || &#x27;default&#x27;; const fooValue = myForm.querySelector(&#x27;input[name=foo]&#x27;)?.value 上面代码使用了?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。 下面是判断对象方法是否存在，如果存在就立即执行的例子。 1iterator.return?.() 上面代码中，iterator.return如果有定义，就会调用该方法，否则iterator.return直接返回undefined，不再执行?.后面的部分。 对于那些可能没有实现的方法，这个运算符尤其有用。 1234if (myForm.checkValidity?.() === false) &#123; // 表单校验失败 return; &#125; 上面代码中，老式浏览器的表单对象可能没有checkValidity()这个方法，这时?.运算符就会返回undefined，判断语句就变成了undefined === false，所以就会跳过下面的代码。 链判断运算符?.有三种写法。 obj?.prop &#x2F;&#x2F; 对象属性是否存在 obj?.[expr] &#x2F;&#x2F; 同上 func?.(...args) &#x2F;&#x2F; 函数或对象方法是否存在 下面是obj?.[expr]用法的一个例子。 1let hex = &quot;#C0FFEE&quot;.match(/#([A-Z]+)/i)?.[1]; 上面例子中，字符串的match()方法，如果没有发现匹配会返回null，如果发现匹配会返回一个数组，?.运算符起到了判断作用。 下面是?.运算符常见形式，以及不使用该运算符时的等价形式。 123456789101112131415a?.b // 等同于 a == null ? undefined : a.b a?.[x] // 等同于 a == null ? undefined : a[x] a?.b() // 等同于 a == null ? undefined : a.b() a?.() // 等同于 a == null ? undefined : a() 上面代码中，特别注意后两种形式，如果a?.b()和a?.()。如果a?.b()里面的a.b有值，但不是函数，不可调用，那么a?.b()是会报错的。a?.()也是如此，如果a不是null或undefined，但也不是函数，那么a?.()会报错。 使用这个运算符，有几个注意点。。 （1）短路机制 本质上，?.运算符相当于一种短路机制，只要不满足条件，就不再往下执行。 123a?.[++x] // 等同于 a == null ? undefined : a[++x] 上面代码中，如果a是undefined或null，那么x不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。 （2）括号的影响 如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。 123(a?.b).c // 等价于 (a == null ? undefined : a.b).c 上面代码中，?.对圆括号外部没有影响，不管a对象是否存在，圆括号后面的.c总是会执行。 一般来说，使用?.运算符的场合，不应该使用圆括号。 （3）报错场合 以下写法是禁止的，会报错。 1234567891011121314// 构造函数 new a?.() new a?.b() // 链判断运算符的右侧有模板字符串 a?.`&#123;b&#125;` a?.b`&#123;c&#125;` // 链判断运算符的左侧是 super super?.() super?.foo // 链运算符用于赋值运算符左侧 a?.b = c （4）右侧不得为十进制数值 为了保证兼容以前的代码，允许foo?.3:0被解析成foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。","path":"2021/12/13/es6链判断运算符/","date":"12-13","excerpt":"","tags":[{"name":"es6","slug":"es6","permalink":"https://wanwan-doudou/github.io/tags/es6/"}]},{"title":"Win11激活","text":"友情提示1、此方去仅用于学习、测试 2、请购买正版 首先我们右键左下角图标，打开Windows终端（管理员） 依次输入以下三条命令： 1.slmgr &#x2F;ipk W269N-WFGWX-YVC9B-4J6C9-T83GX2.slmgr &#x2F;skms kms.03k.org3.slmgr &#x2F;ato 这样你的win11就激活啦","path":"2021/12/12/Win11激活/","date":"12-12","excerpt":"","tags":[{"name":"激活","slug":"激活","permalink":"https://wanwan-doudou/github.io/tags/%E6%BF%80%E6%B4%BB/"}]},{"title":"Java 爬虫","text":"创建一个maven项目 导入依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.10.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.51&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies 创建一个类 12345public class Reptile &#123; public static void main(String[] args) throws IOException &#123; &#125; &#125; 我们要爬取的网页是36壁纸 我们请求一下这个网页 123456789Connection connection = Jsoup // 设置URL .connect(WEB_URL) // 忽略解析不了的类型，强制解析，避免UnsupportedMimeTypeException .ignoreContentType(true) // 设置超时时间(ms) .timeout(60000); Document document = connection.get(); List&lt;String&gt; srcs = document.getElementsByAttribute(&quot;lazysrc&quot;).stream().parallel().map(e -&gt; e.attr(&quot;lazysrc&quot;)).collect(Collectors.toList()); 可以看到数据已经获取到了 接下来我们把它遍历出来 1234srcs.forEach(imgUrl -&gt; &#123; String imgUrlClear = imgUrl.substring(0, imgUrl.lastIndexOf(&quot;.238.390.jpg&quot;)); downloadPicture(imgUrlClear, &quot;E:\\\\壁纸\\\\jail\\\\&quot; + imgUrlClear.substring(imgUrl.lastIndexOf(&quot;/&quot;) + 1)); &#125;); 然后我们把它下载到本地 12345678910111213141516171819public static void downloadPicture(String imageUrl, String path) &#123; URL url = null; try &#123; url = new URL(imageUrl); DataInputStream dataInputStream = new DataInputStream(url.openStream()); FileOutputStream fileOutputStream = new FileOutputStream(new File(path)); ByteArrayOutputStream output = new ByteArrayOutputStream(); byte[] buffer = new byte[4096]; int length; while ((length = dataInputStream.read(buffer)) &gt; 0) &#123; output.write(buffer, 0, length); &#125; fileOutputStream.write(output.toByteArray()); dataInputStream.close(); fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 这是完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.jsoup.Connection; import org.jsoup.Jsoup; import org.jsoup.nodes.Document; import java.io.*; import java.net.URL; import java.util.List; import java.util.stream.Collectors; public class Reptile &#123; static String WEB_URL = &quot;https://www.3gbizhi.com/tag/dongman/&quot;; public static void main(String[] args) throws IOException &#123; Connection connection = Jsoup // 设置URL .connect(WEB_URL) // 忽略解析不了的类型，强制解析，避免UnsupportedMimeTypeException .ignoreContentType(true) // 设置超时时间(ms) .timeout(60000); Document document = connection.get(); List&lt;String&gt; srcs = document.getElementsByAttribute(&quot;lazysrc&quot;).stream().parallel().map(e -&gt; e.attr(&quot;lazysrc&quot;)).collect(Collectors.toList()); srcs.forEach(imgUrl -&gt; &#123; String imgUrlClear = imgUrl.substring(0, imgUrl.lastIndexOf(&quot;.238.390.jpg&quot;)); downloadPicture(imgUrlClear, &quot;E:\\\\壁纸\\\\jail\\\\&quot; + imgUrlClear.substring(imgUrl.lastIndexOf(&quot;/&quot;) + 1)); &#125;); &#125; public static void downloadPicture(String imageUrl, String path) &#123; URL url = null; try &#123; url = new URL(imageUrl); DataInputStream dataInputStream = new DataInputStream(url.openStream()); FileOutputStream fileOutputStream = new FileOutputStream(new File(path)); ByteArrayOutputStream output = new ByteArrayOutputStream(); byte[] buffer = new byte[4096]; int length; while ((length = dataInputStream.read(buffer)) &gt; 0) &#123; output.write(buffer, 0, length); &#125; fileOutputStream.write(output.toByteArray()); dataInputStream.close(); fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 这是下载的壁纸","path":"2021/12/11/Java-爬虫/","date":"12-11","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://wanwan-doudou/github.io/tags/java/"}]},{"title":"CamelCase驼峰插件","text":"发现一个不错的插件分享给大家 打开idea，按下Ctrl+Alt+S 点击Plugins,输入cam下载好后不用重启就能直接使用 按住SHIFT+ALT+U就能直接使用了","path":"2021/12/10/CamelCase驼峰插件/","date":"12-10","excerpt":"","tags":[{"name":"插件","slug":"插件","permalink":"https://wanwan-doudou/github.io/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"基于layui表格的树形扩展","text":"参考根据官方文档入门treeTable树形表格： 1234567891011121314151617181920212223242526272829&#123; elem: &#x27;#tree-table&#x27;,// 必须 url: &#x27;data/table-tree.json&#x27;,// （url和data参数必须设置一个） data: [&#123;&#125;,&#123;&#125;,&#123;&#125;,...], icon_key: &#x27;title&#x27;,// 必须 top_value: 0, primary_key: &#x27;id&#x27;, parent_key: &#x27;pid&#x27;, hide_class: &#x27;layui-hide&#x27;, icon: &#123; open: &#x27;layui-icon layui-icon-triangle-d&#x27;, close: &#x27;layui-icon layui-icon-triangle-r&#x27;, left: 16, &#125;, cols: [&#123; key: &#x27;title&#x27;, title: &#x27;名称&#x27;, width: &#x27;100px&#x27;, template: function(item)&#123;return &#x27;显示内容&#x27;&#125; &#125;,&#123;&#125;,...], checked: &#123; key: &#x27;id&#x27;, data: [0,1,4,10,11,5,2,6,7,3,8,9], &#125;, is_click_icon: false, is_checkbox: false, is_cache: true, end: function(e)&#123;&#125;, &#125;","path":"2021/12/09/基于layui表格的树形扩展/","date":"12-09","excerpt":"","tags":[{"name":"layui","slug":"layui","permalink":"https://wanwan-doudou/github.io/tags/layui/"}]},{"title":"layui中xm select组件","text":"xm-select介绍始于Layui, 下拉选择框的多选解决方案 前身前往formSelectes, 由于渲染速度慢, 代码冗余, 被放弃了 xm-select使用了新的开发方式, 利用preact进行渲染, 大幅度提高渲染速度, 并且可以灵活拓展 xm-select演示站点 支持功能 国际化 - 中文&#x2F;英文 多选 单选 重复选 分组 工具条 创建条目 显示模式 搜索模式 (本地数据过滤, 远程搜索) 分页模式 下拉树 下拉任意 - 可以自己写html 快读上手 直接使用 1234567891011121. 引入 `dist/xm-select.js` 2. 写一个`&lt;div id=&quot;demo1&quot;&gt;&lt;/div&gt;` 3. 渲染 var demo1 = xmSelect.render(&#123; el: &#x27;#demo1&#x27;, data: [ &#123;name: &#x27;水果&#x27;, value: 1, selected: true, disabled: true&#125;, &#123;name: &#x27;蔬菜&#x27;, value: 2, selected: true&#125;, &#123;name: &#x27;桌子&#x27;, value: 3, disabled: true&#125;, &#123;name: &#x27;北京&#x27;, value: 4&#125;, ], &#125;) 二次开发 1231. git clone https://gitee.com/maplemei/xm-select.git 2. cd xm-select 3. yarn 或者 npm install 实例 12345678910111213141516171819202122232425&lt;!-- 占位 --&gt; &lt;div id=&quot;demo1&quot;&gt;&lt;/div&gt; &lt;!-- 引入插件 --&gt; &lt;script src=&quot;../dist/xm-select.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;!-- 渲染页面 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var demo1 = xmSelect.render(&#123; // 这里绑定css选择器 el: &#x27;#demo1&#x27;, // 渲染的数据 data: [ &#123;name: &#x27;水果&#x27;, value: 1, selected: true, disabled: true&#125;, &#123;name: &#x27;蔬菜&#x27;, value: 2, selected: true&#125;, &#123;name: &#x27;桌子&#x27;, value: 3, disabled: true&#125;, &#123;name: &#x27;北京&#x27;, value: 4&#125;, ], &#125;) // 变量, demo1 可以通过API操作 // 获取选中值, demo1.getValue(); // 设置选中值, demo1.setValue([&#123; name: &#x27;动态值&#x27;, value: 999 &#125;]) // ... &lt;/script&gt; 实例 12345678910&lt;div class=&quot;layui-input-block&quot; id=&quot;demo1&quot;&gt; &lt;input autocomplete=&quot;off&quot; class=&quot;layui-input&quot; name=&quot;projectPerson&quot; required=&quot;&quot; type=&quot;hidden&quot;&gt; &lt;/div&gt; &lt;script&gt; var selectName = xmSelect.render(&#123; el: &#x27;#demo1&#x27;, data: [[$&#123;detail.principals&#125;]].map((&#123;username: name, id: value&#125;) =&gt; (&#123;name, value&#125;)) &#125;) &lt;/script&gt;","path":"2021/12/07/layui中xm-select组件/","date":"12-07","excerpt":"","tags":[{"name":"layui","slug":"layui","permalink":"https://wanwan-doudou/github.io/tags/layui/"}]},{"title":"uniapp navigateTo跳转","text":"uni.navigateTo(OBJECT) 保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面。 参考代码： 1&lt;view class=&quot;square-like-user&quot; @tap=&quot;navigateTo(&#x27;/pages/contact/contact-detail/contact-detail?id=&#x27; + itemRe.id)&quot;&gt; 示例 1234//在起始页面跳转到test.vue页面并传递参数 uni.navigateTo(&#123; url: &#x27;test?id=1&amp;name=uniapp&#x27; &#125;); 1234567// 在test.vue页面接受参数 export default &#123; onLoad: function (option) &#123; //option为object类型，会序列化上个页面传递的参数 console.log(option.id); //打印出上个页面传递的参数。 console.log(option.name); //打印出上个页面传递的参数。 &#125; &#125; 12345678910111213141516171819202122232425262728293031323334// 在起始页面跳转到test.vue页面，并监听test.vue发送过来的事件数据 uni.navigateTo(&#123; url: &#x27;pages/test?id=1&#x27;, events: &#123; // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据 acceptDataFromOpenedPage: function(data) &#123; console.log(data) &#125;, someEvent: function(data) &#123; console.log(data) &#125; ... &#125;, success: function(res) &#123; // 通过eventChannel向被打开页面传送数据 res.eventChannel.emit(&#x27;acceptDataFromOpenerPage&#x27;, &#123; data: &#x27;data from starter page&#x27; &#125;) &#125; &#125;) // 在test.vue页面，向起始页通过事件传递数据 onLoad: function(option) &#123; // #ifdef APP-NVUE const eventChannel = this.$scope.eventChannel; // 兼容APP-NVUE // #endif // #ifndef APP-NVUE const eventChannel = this.getOpenerEventChannel(); // #endif eventChannel.emit(&#x27;acceptDataFromOpenedPage&#x27;, &#123;data: &#x27;data from test page&#x27;&#125;); eventChannel.emit(&#x27;someEvent&#x27;, &#123;data: &#x27;data from test page for someEvent&#x27;&#125;); // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据 eventChannel.on(&#x27;acceptDataFromOpenerPage&#x27;, function(data) &#123; console.log(data) &#125;) &#125; url有长度限制，太长的字符串会传递失败，可改用窗体通信、全局变量，另外参数中出现空格等特殊字符时需要对参数进行编码，如下为使用encodeURIComponent对参数进行编码的示例。 1&lt;navigator :url=&quot;&#x27;/pages/test/test?item=&#x27;+ encodeURIComponent(JSON.stringify(item))&quot;&gt;&lt;/navigator&gt; 1&lt;navigator :url=&quot;&#x27;/pages/test/test?item=&#x27;+ encodeURIComponent(JSON.stringify(item))&quot;&gt;&lt;/navigator&gt; 注意： 页面跳转路径有层级限制，不能无限制跳转新页面 跳转到 tabBar 页面只能使用 switchTab 跳转 路由API的目标页面必须是在pages.json里注册的vue页面。如果想打开web url，在App平台可以使用 plus.runtime.openURL或web-view组件；H5平台使用 window.open；小程序平台使用web-view组件（url需在小程序的联网白名单中）。在hello uni-app中有个组件ulink.vue已对多端进行封装，可参考。 APP-NVUE平台暂不支持以this.getOpenerEventChannel()方式获取eventChannel，请换用this.$scope.eventChannel来获取，具体方式请参考上述示例。","path":"2021/12/06/uniapp-navigateTo跳转/","date":"12-06","excerpt":"","tags":[{"name":"uniapp","slug":"uniapp","permalink":"https://wanwan-doudou/github.io/tags/uniapp/"}]},{"title":"命令模式","text":"命令模式的最大优势为将应用分层处理，避免各层耦合 这里举个例子 在市中心逛了很久的街后， 你找到了一家不错的餐厅， 坐在了临窗的座位上。 一名友善的服务员走近你， 迅速记下你点的食物， 写在一张纸上。 服务员来到厨房， 把订单贴在墙上。 过了一段时间， 厨师拿到了订单， 他根据订单来准备食物。 厨师将做好的食物和订单一起放在托盘上。 服务员看到托盘后对订单进行检查， 确保所有食物都是你要的， 然后将食物放到了你的桌上。 那张纸就是一个命令， 它在厨师开始烹饪前一直位于队列中。 命令中包含与烹饪这些食物相关的所有信息。 厨师能够根据它马上开始烹饪， 而无需跑来直接和你确认订单详情。 我们如果不使用命令模式，写出来的代码就如下： 1234567891011121314private static void withoutCommandMode() throws InterruptedException &#123; // 在市中心逛了很久的街后， 你找到了一家不错的餐厅， 坐在了临窗的座位上。 // 一名友善的服务员走近你， 迅速记下你点的食物， 写在一张纸上。 List&lt;String&gt; order = Arrays.asList(&quot;牛排&quot;, &quot;意面&quot;, &quot;芭菲&quot;, &quot;拉菲&quot;); // 服务员来到厨房， 把订单贴在墙上。 System.out.println(&quot;处理订单&quot;); System.out.println(order); // 过了一段时间， 厨师拿到了订单， 他根据订单来准备食物。 Thread.sleep(1000); // 厨师将做好的食物和订单一起放在托盘上。 // 服务员看到托盘后对订单进行检查， 确保所有食物都是你要的， 然后将食物放到了你的桌上。 System.out.println(&quot;检查清单&quot;); System.out.println(order); &#125; 这里明确几个角色： 发送者：此处就是顾客，在本次例子中我们省略掉了，关于发送者的定义为： 发送者 （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。 命令：此处就是纸(Paper抽象类)，我们将执行命令这一操作抽取出来，并且不给它具体参数，让它从预先定义或者让其能够自行获取数据，命令的定义： 命令 （Command） 接口通常仅声明一个执行命令的方法。 1234567891011121314151617181920212223package com.ruben.simplescaffold.desgin.behavior.command.demo.restaurant; import lombok.AllArgsConstructor; /** * 那张纸就是一个命令， 它在厨师开始烹饪前一直位于队列中。 * 命令中包含与烹饪这些食物相关的所有信息。 * 厨师能够根据它马上开始烹饪， 而无需跑来直接和你确认订单详情。 * * @author &lt;achao1441470436@gmail.com&gt; * @since 2021/12/5 0005 16:11 */ @AllArgsConstructor public abstract class Paper &#123; public Waiter waiter; /** * 执行纸上的命令 */ public abstract void execute(); &#125; 具体命令：此处就是PreparePaper和ProcessorPaper，就是Paper的具体实现，定义： 具体命令 （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。 接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。 1234567891011121314151617181920212223package com.ruben.simplescaffold.desgin.behavior.command.demo.restaurant; /** * 拿到厨房去的纸 * * @author &lt;achao1441470436@gmail.com&gt; * @since 2021/12/5 0005 16:19 */ public class PreparePaper extends Paper &#123; public PreparePaper(Waiter waiter) &#123; super(waiter); &#125; /** * 执行纸上的命令 */ @Override public void execute() &#123; // 处理订单，拿到厨房去 waiter.handleOrder(); &#125; &#125; 以及 1234567891011121314151617181920212223package com.ruben.simplescaffold.desgin.behavior.command.demo.restaurant; /** * 拿到顾客桌上的清单，和食物一起放到顾客桌上 * * @author &lt;achao1441470436@gmail.com&gt; * @since 2021/12/5 0005 16:21 */ public class ProcessorPaper extends Paper &#123; public ProcessorPaper(Waiter waiter) &#123; super(waiter); &#125; /** * 执行纸上的命令 */ @Override public void execute() &#123; // 服务员对订单进行检查， 确保所有食物都是顾客要的， 然后将食物放到顾客的桌上 waiter.checkList(); &#125; &#125; 接收者，这里就是我们的服务员(Waiter类)，定义： 接收者 （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。 1234567891011121314151617181920212223242526272829package com.ruben.simplescaffold.desgin.behavior.command.demo.restaurant; import java.util.List; import lombok.AllArgsConstructor; /** * 服务员，接受命令的接收者 * * @author &lt;achao1441470436@gmail.com&gt; * @since 2021/12/5 0005 16:23 */ @AllArgsConstructor public class Waiter &#123; public List&lt;String&gt; order; public void handleOrder() &#123; // 处理订单 System.out.println(&quot;处理订单&quot;); System.out.println(order); &#125; public void checkList() &#123; // 检查清单 System.out.println(&quot;检查清单&quot;); System.out.println(order); &#125; &#125; 客户端，这里就是启动类，定义： 客户端 （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。 1234567891011121314151617181920212223242526272829303132333435363738package com.ruben.simplescaffold.desgin.behavior.command.demo.restaurant; import java.util.Arrays; import java.util.List; /** * 在市中心逛了很久的街后， 你找到了一家不错的餐厅， 坐在了临窗的座位上。 * 一名友善的服务员走近你， 迅速记下你点的食物， 写在一张纸上。 * 服务员来到厨房， 把订单贴在墙上。 * 过了一段时间， 厨师拿到了订单， 他根据订单来准备食物。 * 厨师将做好的食物和订单一起放在托盘上。 * 服务员看到托盘后对订单进行检查， 确保所有食物都是你要的， 然后将食物放到了你的桌上。 * * @author &lt;achao1441470436@gmail.com&gt; * @since 2021/12/5 0005 16:09 */ public class RestaurantApplication &#123; public static void main(String[] args) throws InterruptedException &#123; useCommandMode(); &#125; private static void useCommandMode() throws InterruptedException &#123; // 在市中心逛了很久的街后， 你找到了一家不错的餐厅， 坐在了临窗的座位上。 // 一名友善的服务员走近你， 迅速记下你点的食物， 写在一张纸上。 Waiter waiter = new Waiter(Arrays.asList(&quot;牛排&quot;, &quot;意面&quot;, &quot;芭菲&quot;, &quot;拉菲&quot;)); Paper paper = new PreparePaper(waiter); // 服务员来到厨房， 把订单贴在墙上。 paper.execute(); // 过了一段时间， 厨师拿到了订单， 他根据订单来准备食物。 Thread.sleep(1000); // 厨师将做好的食物和订单一起放在托盘上。 // 服务员看到托盘后对订单进行检查， 确保所有食物都是你要的， 然后将食物放到了你的桌上。 paper = new ProcessorPaper(waiter); paper.execute(); &#125; &#125;","path":"2021/12/05/命令模式/","date":"12-05","excerpt":"","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://wanwan-doudou/github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"如何给博客添加看板娘","text":"参考Live2D 插件首先从GitHub上获取项目 这是模型链接 引用 CSS 资源在你网站的 head 标签内引用本项目的 CSS 样式表文件。 12&lt;!-- 引用看板娘交互所需的样式表 --&gt; &lt;link href=&#x27;https://kwydy.gitee.io/Pio/static/pio.css&#x27; rel=&#x27;stylesheet&#x27; type=&#x27;text/css&#x27;/&gt; 引用 JS 资源在你项目的页尾部分引用本项目的 JS 文件。 1234&lt;!-- 引用 Live2D 核心组件 --&gt; &lt;script src=&#x27;https://kwydy.gitee.io/Pio/static/l2d.js&#x27;&gt;&lt;/script&gt; &lt;!-- 引用看板娘交互组件 --&gt; &lt;script src=&#x27;https://kwydy.gitee.io/Pio/static/pio.js&#x27;&gt;&lt;/script&gt; 插入 DOM 内容 PS：在独立使用的情况下，看板娘的自定位置和高宽无法通过 JS 直接设置，请根据需要自行修改或使用后端语言进行输出。 1234&lt;div class=&quot;pio-container right&quot;&gt; &lt;div class=&quot;pio-action&quot;&gt;&lt;/div&gt; &lt;canvas id=&quot;pio&quot; width=&quot;280&quot; height=&quot;335&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; 设置启动器加载完 JS 文件后并不会立即自动生成看板娘，你需要编写一段启动代码来运行看板娘。 123456789101112131415161718192021222324252627&lt;script&gt; var pio = new Paul_Pio(&#123; &quot;mode&quot;: &quot;fixed&quot;, &quot;hidden&quot;: false, &quot;content&quot;: &#123; &quot;welcome&quot;: [&quot;欢迎来到这个爱酱不太聪明的博客~&quot;, &quot;欧尼酱！&quot;], &quot;touch&quot;: [&quot;今天也是元气满满的一天！&quot;, &quot;欧尼酱！&quot;, &quot;哈哈哈哈，不要戳了&quot;], &quot;skin&quot;: [&quot;想看看我的新服装吗？&quot;, &quot;新衣服真漂亮~&quot;], &quot;home&quot;: &quot;点击这里回到首页！&quot;, &quot;link&quot;: &quot;https://kwydy.gitee.io/&quot;, &quot;close&quot;: &quot;QWQ 有缘再会吧~&quot;, // &quot;referer&quot;: &quot;你通过 %t 来到了这里&quot;, &quot;custom&quot;: [ &#123; &quot;selector&quot;: &quot;.comment-form&quot;, &quot;text&quot;: [&quot;欢迎参与本文评论，别发小广告噢~&quot;, &quot;快来参加本文的评论吧~&quot;] &#125; ] &#125;, &quot;model&quot;: [&quot;https://kwydy.gitee.io/rem/model.json&quot;] &#125;); var resourcesPath = &#x27;/&#x27;; // 指定资源文件（模型）保存的路径 var backImageName = &#x27;&#x27;; // 指定背景图片 var modelDir = [&#x27;supa&#x27;]; // 指定需要加载的模型 initDefine(resourcesPath, backImageName, modelDir); // 初始化模型 window.localStorage.clear(); // 清理localStorage &lt;/script&gt; 启动器的必备参数可以参考本文档的 参数 节点。","path":"2021/12/04/如何给博客添加看板娘/","date":"12-04","excerpt":"","tags":[{"name":"博客","slug":"博客","permalink":"https://wanwan-doudou/github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"vue中slot插槽","text":"我们在进行vue开发中，经常会使用到slot插槽 插槽允许我们在父组件引用子组件时，在组件其中放一段可以带标签的元素，甚至放入其他组件等 例如我这里定义一个组件 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;header&gt;&lt;slot name=&quot;header&quot; :user=&quot;user&quot;&gt;-------&lt;/slot&gt;&lt;/header&gt; &lt;main&gt;&lt;slot :user=&quot;user&quot;&gt;默认内容&lt;/slot&gt;&lt;/main&gt; &lt;footer&gt;&lt;slot name=&quot;footer&quot; :user=&quot;user&quot;&gt;-------&lt;/slot&gt;&lt;/footer&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; user: &#123; name: &#x27;ruben&#x27; &#125; &#125;; &#125; &#125;; &lt;/script&gt; 其中包含三个外部标签header、main、footer 我们在父页面外部引用时就可以这么写： 1234567891011&lt;navigation-link&gt; &lt;template v-slot:header&gt; ----传入头部---- &lt;/template&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; 插槽&#123;&#123; slotProps.user.name &#125;&#125; &lt;/template&gt; &lt;template v-slot:footer&gt; ----传入底部---- &lt;/template&gt; &lt;/navigation-link&gt; 这样我们template标签内的内容会根据v-slot指定的插槽名自动匹配上面的name 注意，我这里使用的是新版api，旧版已被废弃，但仍然可使用，感兴趣可以看官方文档 最后渲染出来的效果：当然这里我每个插槽在组件内定义时都写了默认值，这样就算我们没有传入，也可以使用默认值 这里我们可能还会有一个需求，我们想访问子组件内部的值怎么办？因为我们从父页面传给子组件的插槽的模板引用到的作用域是外部，也就是我们父页面的，此时大家注意到我定义组件时，绑定了一个user标签，指向我们子组件内部的值user这样，我们在外部使用时就可以像我上方那样，使用v-slot设置一个属性变量，通过它就能访问到子组件内部的值当你会用这个了之后你还可以使用ES6中变量的解构赋值，省掉我们上面定义slotProps变量这一步骤 而且:default也是可以省略的这里可以看到我传入的template标签很繁重，其实如果我们只给默认的slot传模板的话，可以简写为下方形式： 12&lt;!-- 缩写形式 只能在只有一个slot下使用，如有多个，则需要写全 --&gt; &lt;navigation-link v-slot:header=&quot;&#123; user: person &#125;&quot;&gt;缩写&#123;&#123; person.name &#125;&#125;&lt;/navigation-link&gt; 注意上方我还将user进行了重命名为person vue官方文档还提到可以使用如下语法设置备选值，用于在user为undefined的时候，但我发现我引入这段代码会编译报错，暂时不是很想去探究，有可能是我的版本问题吧 1&lt;navigation-link v-slot=&quot;&#123; user = &#123; name: &#x27;Guest&#x27; &#125; &#125;&quot;&gt;备用值&#123;&#123; user.name &#125;&#125;&lt;/navigation-link&gt; 我们在写插槽名的时候，其实可以使用动态插槽名如下，并且v-slot在指定插槽名的时候也可以进行简写为#： 1&lt;navigation-link #[dynamicSlotName]=&quot;&#123; user &#125;&quot;&gt;动态插槽&#123;&#123; user.name &#125;&#125;&lt;/navigation-link&gt; 这里dynamicSlotName在下方定义如下：最后完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;div&gt; &lt;div :class=&quot;[&#123; active: active &#125;, isButton ? prefix + &#x27;-button&#x27; : null]&quot;&gt;:class=&quot;[&#123; active: active &#125;, isButton ? prefix + &#x27;-button&#x27; : null]&quot;&lt;/div&gt; &lt;div :class=&quot;&#123; active, [`$&#123;prefix&#125;-button`]: isButton &#125;&quot;&gt;:class=&quot;&#123; active, [`$&#123;prefix&#125;-button`]: isButton &#125;&quot;&lt;/div&gt; &lt;hello-world msg=&quot;Hello World&quot;&gt;&lt;/hello-world&gt; &lt;div v-html=&quot;&#x27;&lt;div class=\\&#x27;ruben-html\\&#x27;&gt;我是富文本&lt;/div&gt;&#x27;&quot;&gt;&lt;/div&gt; &lt;navigation-link&gt; &lt;template v-slot:header&gt; ----传入头部---- &lt;/template&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; 插槽&#123;&#123; slotProps.user.name &#125;&#125; &lt;/template&gt; &lt;template v-slot:footer&gt; ----传入底部---- &lt;/template&gt; &lt;/navigation-link&gt; &lt;navigation-link&gt; &lt;template v-slot=&quot;&#123; user &#125;&quot;&gt; 解构&#123;&#123; user.name &#125;&#125; &lt;/template&gt; &lt;/navigation-link&gt; &lt;!-- 缩写形式 只能在只有一个slot下使用，如有多个，则需要写全 --&gt; &lt;navigation-link v-slot:header=&quot;&#123; user: person &#125;&quot;&gt;缩写&#123;&#123; person.name &#125;&#125;&lt;/navigation-link&gt; &lt;!-- &lt;navigation-link v-slot=&quot;&#123; user = &#123; name: &#x27;Guest&#x27; &#125; &#125;&quot;&gt;备用值&#123;&#123; user.name &#125;&#125;&lt;/navigation-link&gt; --&gt; &lt;navigation-link #[dynamicSlotName]=&quot;&#123; user &#125;&quot;&gt;动态插槽&#123;&#123; user.name &#125;&#125;&lt;/navigation-link&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import HelloWorld from &#x27;@/components/HelloWorld.vue&#x27;; import NavigationLink from &#x27;@/components/navigation-link.vue&#x27;; export default &#123; components: &#123; HelloWorld, NavigationLink &#125;, data() &#123; return &#123; active: true, isButton: true, prefix: &#x27;ruben&#x27;, dynamicSlotName: &#x27;footer&#x27; &#125;; &#125; &#125;; &lt;/script&gt; &lt;style scoped&gt; .hello &#123; text-align: center; &#125; &gt;&gt;&gt; .hello-ruben &#123; color: #f06431; &#125; .hello /deep/ a &#123; color: #0000ee; &#125; &gt;&gt;&gt; .ruben-html &#123; color: #ff0000; &#125; &lt;/style&gt;","path":"2021/12/03/vue中slot插槽/","date":"12-03","excerpt":"","tags":[{"name":"vue","slug":"vue","permalink":"https://wanwan-doudou/github.io/tags/vue/"}]},{"title":"layui content传值","text":"layui弹窗层 content可传入的值是灵活多变的，不仅可以传入普通的html内容，还可以指定DOM，更可以随着type的不同而不同。 1234567891011121314151617181920212223242526272829303132/!* 如果是页面层 */ layer.open(&#123; type: 1, content: &#x27;传入任意的文本或html&#x27; //这里content是一个普通的String &#125;); layer.open(&#123; type: 1, content: $(&#x27;#id&#x27;) //这里content是一个DOM，注意：最好该元素要存放在body最外层，否则可能被其它的相对元素所影响 &#125;); //Ajax获取 $.post(&#x27;url&#x27;, &#123;&#125;, function(str)&#123; layer.open(&#123; type: 1, content: str //注意，如果str是object，那么需要字符拼接。 &#125;); &#125;); /!* 如果是iframe层 */ layer.open(&#123; type: 2, content: &#x27;http://sentsin.com&#x27; //这里content是一个URL，如果你不想让iframe出现滚动条，你还可以content: [&#x27;http://sentsin.com&#x27;, &#x27;no&#x27;] &#125;); /!* 如果是用layer.open执行tips层 */ layer.open(&#123; type: 4, content: [&#x27;内容&#x27;, &#x27;#id&#x27;] //数组第二项即吸附元素选择器或者DOM &#125;); 1234567891011121314parent.layer.open(&#123; //content:`$&#123;data.item.title&#125;` content: &#x27;&lt;div id=&quot;contentDiv&quot; style=&quot;margin-left:10px;margin-top:10px;&quot;&gt;&lt;input id=&quot;txtType&quot; style=&quot;width:180px;height:50px;resize:none;border-radius:6px;&quot; &gt;&lt;/input&gt;&lt;/div&gt;&#x27; , btn: [&#x27;确定修改&#x27;] , yes: function (index, layero) &#123; var txtType = top.$(&#x27;#txtType&#x27;).val(); console.log(txtType); treeTable.render(re); layer.close(index); &#125; , cancel: function () &#123; //return false 开启该代码可禁止点击该按钮关闭 &#125; &#125;);","path":"2021/12/02/layui-content传值/","date":"12-02","excerpt":"","tags":[{"name":"layui","slug":"layui","permalink":"https://wanwan-doudou/github.io/tags/layui/"}]},{"title":"Map实现连表查询","text":"通过Map实现连表查询 123456789101112131415@GetMapping(&quot;product/edit&quot;) public String productEdit(String id, Model model) &#123; ProjectInfo projectInfo = Opt.ofNullable(id).map(ProjectInfo.builder().build()::selectById).orElseGet(() -&gt; ProjectInfo.builder().build()); List&lt;MemberInfo&gt; members = MemberInfo.builder().build().selectList(Wrappers.lambdaQuery(MemberInfo.builder().status(MemberInfoStatusEnum.AUTHORIZED).build())); List&lt;ProjectCategory&gt; categories = ProjectCategory.builder().build().selectAll(); Map&lt;Long, MemberInfo&gt; memberMap = SimpleQuery.list2Map(members, MemberInfo::getId, Function.identity()); Map&lt;Long, ProjectCategory&gt; projects = SimpleQuery.list2Map(categories, ProjectCategory::getId, Function.identity()); ProjectVO vo = BeanUtils.copyProperties(projectInfo, ProjectVO::new); vo.setMemberInfo(memberMap.get(projectInfo.getMemberId())); vo.setCategory(projects.get(projectInfo.getCategoryId())); model.addAttribute(AttrKeyConst.MEMBERS, members); model.addAttribute(AttrKeyConst.CATEGORIES, projects); model.addAttribute(AttrKeyConst.DETAIL, vo); return &quot;admin/product/edit&quot;; &#125;","path":"2021/12/01/Map实现连表查询/","date":"12-01","excerpt":"","tags":[{"name":"java","slug":"java","permalink":"https://wanwan-doudou/github.io/tags/java/"}]},{"title":"layui 实现不同用户操作权限不同","text":"在代码里面我们会遇到不同用户操作权限不同能用的功能也不一样 比如：我们能操作自己操作的群聊，但是不能修改其他群聊的数据 下面我们有个需求，一个是我创建的群，一个是我加入的群 我从layui数据表格中点击我加如的群时，操作功能模块删除掉 由于我们是动态创建表格的，所以我们先将对象封装到一个数组里面 1234567891011121314151617181920212223242526272829303132333435363738let cols = [ [ &#123; field: &#x27;id&#x27;, title: &#x27;ID&#x27;, width: 80, hide: true, &#125;, &#123; field: &#x27;cover&#x27; , title: &#x27;头像&#x27; , templet: &#x27;#cover&#x27; , width: 70, &#125;, &#123; field: &#x27;contactPerson&#x27; , title: &#x27;联系人&#x27; , edit: &#x27;text&#x27; , width: 100, &#125;, &#123; field: &#x27;contactMobile&#x27; , title: &#x27;联系电话&#x27; , edit: &#x27;text&#x27; , width: 160, &#125;, &#123; field: &#x27;name&#x27; , title: &#x27;工作单位&#x27; , edit: &#x27;text&#x27;, &#125;, &#123; field: &#x27;email&#x27; , title: &#x27;联系邮箱&#x27; , edit: &#x27;text&#x27;, &#125;, &#123; field: &#x27;addressDetail&#x27; , title: &#x27;详细地址&#x27; , edit: &#x27;text&#x27; , width: 160, &#125; ] ] 在创建时进行判断 12345678910111213if (searchForm.queryType == &#x27;JOIN&#x27;) &#123; if (~optionIndex) &#123; cols[0].splice(optionIndex, 1) &#125; &#125; else &#123; if (!~optionIndex) &#123; cols[0].push(&#123; title: &#x27;操作&#x27;, toolbar: &#x27;#test-table-toolbar-barDemo&#x27;, width: 140, &#125;) &#125; &#125; 1234567if (searchForm.queryType == &#x27;MADE&#x27; &amp;&amp; !~cols.flat(Infinity).map((&#123;title&#125;) =&gt; title).findIndex(t =&gt; t == &#x27;操作&#x27;)) &#123; cols[0].push(&#123; title: &#x27;操作&#x27;, toolbar: &#x27;#test-table-toolbar-barDemo&#x27;, width: 140, &#125;) &#125;","path":"2021/11/30/layui-实现不同用户操作权限不同/","date":"11-30","excerpt":"","tags":[{"name":"layui","slug":"layui","permalink":"https://wanwan-doudou/github.io/tags/layui/"}]},{"title":"MyBatis-Plus 条件构造器 参数问题","text":"今天写项目遇到一个代码没看明白 1return page(page, CommonWrappers.inWrapper(MemberInfo::getId, list).like(StrUtil.isNotBlank(adminGroupDTO.getName()), MemberInfo::getName, adminGroupDTO.getName())); 当时看到条件构造器为什么传了三个参数 于是我到MyBatis-Plus官网找到了答案 第一个参数进行判断，例如： 1like(boolean condition, &quot;name&quot;, &quot;王&quot;) 当Boolean成立时才会执行 1name like &#x27;%王%&#x27;","path":"2021/11/29/mybatis-plus-条件构造器-参数问题/","date":"11-29","excerpt":"","tags":[{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://wanwan-doudou/github.io/tags/mybatis-plus/"}]}],"categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://wanwan-doudou/github.io/tags/docker/"},{"name":"Vue","slug":"Vue","permalink":"https://wanwan-doudou/github.io/tags/Vue/"},{"name":"PaddleOCR","slug":"PaddleOCR","permalink":"https://wanwan-doudou/github.io/tags/PaddleOCR/"},{"name":"go","slug":"go","permalink":"https://wanwan-doudou/github.io/tags/go/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://wanwan-doudou/github.io/tags/RabbitMQ/"},{"name":"python","slug":"python","permalink":"https://wanwan-doudou/github.io/tags/python/"},{"name":"破解","slug":"破解","permalink":"https://wanwan-doudou/github.io/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"vue","slug":"vue","permalink":"https://wanwan-doudou/github.io/tags/vue/"},{"name":"java","slug":"java","permalink":"https://wanwan-doudou/github.io/tags/java/"},{"name":"elementUI","slug":"elementUI","permalink":"https://wanwan-doudou/github.io/tags/elementUI/"},{"name":"npm","slug":"npm","permalink":"https://wanwan-doudou/github.io/tags/npm/"},{"name":"git","slug":"git","permalink":"https://wanwan-doudou/github.io/tags/git/"},{"name":"踩坑","slug":"踩坑","permalink":"https://wanwan-doudou/github.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"https://wanwan-doudou/github.io/tags/mybatis-plus/"},{"name":"博客美化","slug":"博客美化","permalink":"https://wanwan-doudou/github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"},{"name":"linux","slug":"linux","permalink":"https://wanwan-doudou/github.io/tags/linux/"},{"name":"并发编程","slug":"并发编程","permalink":"https://wanwan-doudou/github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://wanwan-doudou/github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"uni-app","slug":"uni-app","permalink":"https://wanwan-doudou/github.io/tags/uni-app/"},{"name":"sa-Token","slug":"sa-Token","permalink":"https://wanwan-doudou/github.io/tags/sa-Token/"},{"name":"es6","slug":"es6","permalink":"https://wanwan-doudou/github.io/tags/es6/"},{"name":"每日一个小技巧","slug":"每日一个小技巧","permalink":"https://wanwan-doudou/github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"uniapp","slug":"uniapp","permalink":"https://wanwan-doudou/github.io/tags/uniapp/"},{"name":"uView","slug":"uView","permalink":"https://wanwan-doudou/github.io/tags/uView/"},{"name":"echarts","slug":"echarts","permalink":"https://wanwan-doudou/github.io/tags/echarts/"},{"name":"Opt","slug":"Opt","permalink":"https://wanwan-doudou/github.io/tags/Opt/"},{"name":"stream","slug":"stream","permalink":"https://wanwan-doudou/github.io/tags/stream/"},{"name":"前端","slug":"前端","permalink":"https://wanwan-doudou/github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"数据库","slug":"数据库","permalink":"https://wanwan-doudou/github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"element","slug":"element","permalink":"https://wanwan-doudou/github.io/tags/element/"},{"name":"hutool","slug":"hutool","permalink":"https://wanwan-doudou/github.io/tags/hutool/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://wanwan-doudou/github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"layui","slug":"layui","permalink":"https://wanwan-doudou/github.io/tags/layui/"},{"name":"jquery","slug":"jquery","permalink":"https://wanwan-doudou/github.io/tags/jquery/"},{"name":"激活","slug":"激活","permalink":"https://wanwan-doudou/github.io/tags/%E6%BF%80%E6%B4%BB/"},{"name":"插件","slug":"插件","permalink":"https://wanwan-doudou/github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"https://wanwan-doudou/github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"博客","slug":"博客","permalink":"https://wanwan-doudou/github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}